<!DOCTYPE html>
<html lang="en">
<head>
Â  <meta charset="UTF-8" />
Â  <meta
Â  Â  name="viewport"
Â  Â  content="width=device-width, initial-scale=1.0"
/>
Â  <title>ORBITAL DEFENSE COMMAND</title>

Â  Â  <meta http-equiv="Content-Security-Policy"
Â  Â  Â  Â  content="default-src 'self' data: blob:;
Â  Â  Â  Â  Â  Â  Â  Â  Â script-src 'self' 'unsafe-inline';
Â  Â  Â  Â  Â  Â  Â  Â  Â style-srcÂ  'self' 'unsafe-inline';
Â  Â  Â  Â  Â  Â  Â  Â  Â img-srcÂ  Â  'self' data: blob:;">

Â  <style>
Â  Â  * { margin: 0; padding: 0; box-sizing: border-box; }
Â  Â  body {
Â  Â  Â  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
Â  Â  Â  background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
Â  Â  Â  color: #fff; overflow: hidden; height: 100vh; display: flex; flex-direction: column;
Â  Â  }
Â  Â  #header {
Â  Â  Â  background: rgba(0, 0, 0, 0.8); padding: 10px 20px;
Â  Â  Â  display: flex; justify-content: space-between; align-items: center;
Â  Â  Â  border-bottom: 2px solid #00ffcc; box-shadow: 0 2px 20px rgba(0, 255, 204, 0.3);
Â  Â  }
Â  Â  .stat-display { display: flex; gap: 30px; font-size: 18px; font-weight: bold; }
Â  Â  .stat-item { color: #00ffcc; text-shadow: 0 0 10px rgba(0, 255, 204, 0.5); }
Â  Â  .stat-label { color: #8899aa; margin-right: 5px; }
Â  Â  #gameContainer { flex: 1; display: flex; position: relative; }
Â  Â  #canvas {
Â  Â  Â  background: radial-gradient(ellipse at center, #1a2332 0%, #0a0e1a 100%);
Â  Â  Â  border: 2px solid #00ffcc; box-shadow: 0 0 50px rgba(0, 255, 204, 0.2); margin: 20px;
Â  Â  }
Â  Â  #sidePanel {
Â  Â  Â  width: 350px; background: rgba(0, 0, 0, 0.9); padding: 20px; overflow-y: auto;
Â  Â  Â  border-left: 2px solid #00ffcc;
Â  Â  }
Â  Â  .panel-section { margin-bottom: 25px; padding: 15px; background: rgba(26, 31, 58, 0.5);
Â  Â  Â  border-radius: 8px; border: 1px solid rgba(0, 255, 204, 0.3);}
Â  Â  .section-title {
Â  Â  Â  font-size: 20px; color: #00ffcc; margin-bottom: 15px; text-transform: uppercase; letter-spacing: 2px;
Â  Â  Â  text-shadow: 0 0 15px rgba(0, 255, 204, 0.7);
Â  Â  }
Â  Â  .unit-card {
Â  Â  Â  background: rgba(0, 255, 204, 0.1); border: 1px solid #00ffcc; padding: 12px; margin-bottom: 12px;
Â  Â  Â  border-radius: 5px; cursor: pointer; transition: all 0.3s ease; position: relative; overflow: hidden;
Â  Â  }
Â  Â  .unit-card::before {
Â  Â  Â  content: ''; position: absolute; inset: -2px;
Â  Â  Â  background: linear-gradient(45deg, #00ffcc, #0099ff, #00ffcc);
Â  Â  Â  border-radius: 5px; opacity: 0; z-index: -1; transition: opacity 0.3s ease;
Â  Â  }
Â  Â  .unit-card:hover::before { opacity: 0.5; }
Â  Â  .unit-card:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0, 255, 204, 0.4); }
Â  Â  .unit-card.selected { background: rgba(0, 255, 204, 0.3); border-color: #fff; }
Â  Â  .unit-card.disabled { opacity: 0.5; cursor: not-allowed; }
Â  Â  .unit-name { font-size: 16px; font-weight: bold; color: #fff; margin-bottom: 5px; }
Â  Â  .unit-stats { font-size: 12px; color: #8899aa; line-height: 1.5; }
Â  Â  .unit-cost { font-size: 14px; color: #ffaa00; font-weight: bold; margin-top: 5px; }
Â  Â  .upgrade-button {
Â  Â  Â  background: linear-gradient(135deg, #00ffcc, #0099ff); border: none; color: #000; padding: 8px 16px; border-radius: 4px; cursor: pointer;
Â  Â  Â  font-weight: bold; margin-top: 8px; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 1px;
Â  Â  }
Â  Â  .upgrade-button:hover:not(:disabled) { transform: scale(1.05); box-shadow: 0 5px 20px rgba(0, 255, 204, 0.6); }
Â  Â  .upgrade-button:disabled { opacity: 0.5; cursor: not-allowed; background: #555; }
Â  Â  #menuOverlay {
Â  Â  Â  position: fixed; inset: 0; background: rgba(0, 0, 0, 0.95);
Â  Â  Â  display: flex; justify-content: center; align-items: center; z-index: 1000;
Â  Â  }
Â  Â  .menu-container {
Â  Â  Â  background: linear-gradient(135deg, #1a2332 0%, #0a0e1a 100%); border: 2px solid #00ffcc; border-radius: 15px; padding: 40px; text-align: center;
Â  Â  Â  box-shadow: 0 0 50px rgba(0, 255, 204, 0.5); max-width: 500px;
Â  Â  }
Â  Â  .game-title {
Â  Â  Â  font-size: 48px; color: #00ffcc; margin-bottom: 10px;
Â  Â  Â  text-shadow: 0 0 30px rgba(0, 255, 204, 0.8); letter-spacing: 3px; animation: glow 2s ease-in-out infinite alternate;
Â  Â  }
Â  Â  @keyframes glow { from { text-shadow: 0 0 30px rgba(0, 255, 204, 0.8);} to { text-shadow: 0 0 40px rgba(0, 255, 204, 1), 0 0 50px rgba(0, 153, 255, 0.8);} }
Â  Â  .game-subtitle { font-size: 18px; color: #8899aa; margin-bottom: 30px; letter-spacing: 2px; }
Â  Â  .menu-button {
Â  Â  Â  background: linear-gradient(135deg, #00ffcc, #0099ff); border: none; color: #000; padding: 15px 40px; margin: 10px;
Â  Â  Â  border-radius: 8px; cursor: pointer; font-size: 18px; font-weight: bold; text-transform: uppercase; letter-spacing: 2px; transition: all 0.3s ease; display: block; width: 100%;
Â  Â  }
Â  Â  .menu-button:hover { transform: scale(1.05); box-shadow: 0 10px 30px rgba(0, 255, 204, 0.6); }
Â  Â  .menu-button.secondary { background: transparent; border: 2px solid #00ffcc; color: #00ffcc; }
Â  Â  .high-scores { margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(0, 255, 204, 0.3); }
Â  Â  .high-score-item { display: flex; justify-content: space-between; padding: 8px; margin: 5px 0; background: rgba(0, 255, 204, 0.1); border-radius: 4px; }
Â  Â  #pauseMenu { display: none; }
Â  Â  .warning-flash { animation: warningFlash 0.5s ease-in-out infinite alternate; }
Â  Â  @keyframes warningFlash { from { background: rgba(255, 0, 0, 0.3);} to { background: rgba(255, 0, 0, 0.6);} }
Â  Â  .particle { position: absolute; pointer-events: none; border-radius: 50%; }
Â  Â  #waveTimer {
Â  Â  Â  position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
Â  Â  Â  font-size: 24px; color: #ffaa00; font-weight: bold; text-shadow: 0 0 20px rgba(255, 170, 0, 0.8);
Â  Â  Â  background: rgba(0, 0, 0, 0.8); padding: 10px 20px; border-radius: 8px; border: 2px solid #ffaa00;
Â  Â  }
Â  Â  .speed-control {
Â  Â  Â  position: absolute; bottom: 30px; left: 30px; display: flex; gap: 10px;
Â  Â  Â  background: rgba(0, 0, 0, 0.8); padding: 10px; border-radius: 8px; border: 1px solid #00ffcc;
Â  Â  }
Â  Â  .speed-button { background: rgba(0, 255, 204, 0.2); border: 1px solid #00ffcc; color: #00ffcc; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.2s ease; }
Â  Â  .speed-button:hover { background: rgba(0, 255, 204, 0.4); }
Â  Â  .speed-button.active { background: #00ffcc; color: #000; }
Â  Â  .notification {
Â  Â  Â  position: fixed; top: 20px; right: 20px; background: rgba(0, 0, 0, 0.9); color: #00ffcc; padding: 15px 25px;
Â  Â  Â  border-radius: 8px; border: 2px solid #00ffcc; z-index: 2000; animation: slideIn 0.3s ease-out; max-width: 360px; text-align: left;
Â  Â  }
Â  Â  @keyframes slideIn { from { transform: translateX(100%); opacity: 0;} to { transform: translateX(0); opacity: 1;} }
Â  Â  .boss-warning {
Â  Â  Â  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
Â  Â  Â  background: rgba(255, 0, 0, 0.9); color: #fff; padding: 30px; border-radius: 15px;
Â  Â  Â  font-size: 32px; font-weight: bold; text-align: center; z-index: 2000; animation: bossWarning 3s ease-in-out;
Â  Â  }
Â  Â  @keyframes bossWarning { 0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5);} 50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1);} }
Â  Â  .achievement {
Â  Â  Â  position: fixed; bottom: 20px; right: 20px; background: linear-gradient(135deg, #ffaa00, #ff6600);
Â  Â  Â  color: #000; padding: 15px 25px; border-radius: 8px; font-weight: bold; z-index: 2000; animation: achievementPop 3s ease-out;
Â  Â  }
Â  Â  @keyframes achievementPop { 0% { transform: translateY(100px); opacity: 0; } 20% { transform: translateY(0); opacity: 1; } 80% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(100px); opacity: 0; } }
Â  </style>
</head>
<body>
Â  <div id="header">
Â  Â  <div class="stat-display">
Â  Â  Â  <div class="stat-item"><span class="stat-label">WAVE:</span><span id="waveCount">1</span></div>
Â  Â  Â  <div class="stat-item"><span class="stat-label">CREDITS:</span><span id="credits">1000</span></div>
Â  Â  Â  <div class="stat-item"><span class="stat-label">SCORE:</span><span id="score">0</span></div>
Â  Â  Â  <div class="stat-item"><span class="stat-label">TOWER HP:</span><span id="towerHp">100/100</span></div>
Â  Â  </div>
Â  Â  <div>
Â  Â  Â  <button id="pauseBtn" class="upgrade-button">PAUSE</button>
Â  Â  Â  <button id="saveBtn" class="upgrade-button">SAVE</button>
Â  Â  Â  <button id="menuBtn" class="upgrade-button">MENU</button>
Â  Â  </div>
Â  </div>

Â  <div id="gameContainer">
Â  Â  <canvas id="canvas"></canvas>
Â  Â  <div id="waveTimer"></div>
Â  Â  <div class="speed-control">
Â  Â  Â  <button class="speed-button active" data-speed="1">1x</button>
Â  Â  Â  <button class="speed-button" data-speed="2">2x</button>
Â  Â  Â  <button class="speed-button" data-speed="3">3x</button>
Â  Â  </div>
Â  Â  <div id="sidePanel">
Â  Â  Â  <div class="panel-section">
Â  Â  Â  Â  <div class="section-title">Deploy Units</div>
Â  Â  Â  Â  <div id="unitSelection"></div>
Â  Â  Â  </div>
Â  Â  Â  <div class="panel-section">
Â  Â  Â  Â  <div class="section-title">Upgrades</div>
Â  Â  Â  Â  <div id="upgradesSection"></div>
Â  Â  Â  </div>
Â  Â  Â  <div class="panel-section">
Â  Â  Â  Â  <div class="section-title">Wave Info</div>
Â  Â  Â  Â  <div id="waveInfo"></div>
Â  Â  Â  </div>
Â  Â  Â  <div class="panel-section">
Â  Â  Â  Â  <div class="section-title">Achievements</div>
Â  Â  Â  Â  <div id="achievementsSection"></div>
Â  Â  Â  </div>
Â  Â  </div>
Â  </div>

Â  <div id="menuOverlay">
Â  Â  <div class="menu-container" id="mainMenu">
Â  Â  Â  <h1 class="game-title">ORBITAL DEFENSE</h1>
Â  Â  Â  <p class="game-subtitle">COMMAND CENTER ALPHA-9</p>
Â  Â  Â  <button id="newGameBtn" class="menu-button">NEW MISSION</button>
Â  Â  Â  <button id="continueBtn" class="menu-button secondary">CONTINUE MISSION</button>
Â  Â  Â  <button id="dailyBtn" class="menu-button secondary">DAILY CHALLENGE</button>
Â  Â  Â  <div class="high-scores">
Â  Â  Â  Â  <div class="section-title">TOP COMMANDERS</div>
Â  Â  Â  Â  <div id="highScoresList"></div>
Â  Â  Â  </div>
Â  Â  </div>
Â  Â  <div class="menu-container" id="pauseMenu" style="display: none;">
Â  Â  Â  <h2 class="game-title">MISSION PAUSED</h2>
Â  Â  Â  <button id="resumeBtn" class="menu-button">RESUME</button>
Â  Â  Â  <button id="saveProgressBtn" class="menu-button secondary">SAVE PROGRESS</button>
Â  Â  Â  <button id="abandonBtn" class="menu-button secondary">ABANDON MISSION</button>
Â  Â  </div>
Â  Â  <div class="menu-container" id="gameOverMenu" style="display: none;">
Â  Â  Â  <h2 class="game-title">MISSION FAILED</h2>
Â  Â  Â  <p id="finalScore" style="font-size: 24px; color: #ffaa00; margin: 20px 0;"></p>
Â  Â  Â  <button id="newMissionBtn" class="menu-button">NEW MISSION</button>
Â  Â  Â  <button id="mainMenuBtn" class="menu-button secondary">MAIN MENU</button>
Â  Â  </div>
Â  Â  Â  </div>

Â  <script>
Â  (function () {
Â  Â  console.log('[ODC] Bootstrappingâ€¦');

Â  Â  class ObjectPool {
Â  Â  Â  constructor(createFn, resetFn, initialSize = 50) {
Â  Â  Â  Â  this.createFn = createFn; this.resetFn = resetFn;
Â  Â  Â  Â  this.pool = []; this.active = [];
Â  Â  Â  Â  for (let i = 0; i < initialSize; i++) this.pool.push(this.createFn());
Â  Â  Â  }
Â  Â  Â  get() { let obj = this.pool.pop(); if (!obj) obj = this.createFn(); this.active.push(obj); return obj; }
Â  Â  Â  release(obj) { const idx = this.active.indexOf(obj); if (idx > -1) { this.active.splice(idx, 1); this.resetFn(obj); this.pool.push(obj); } }
Â  Â  Â  releaseAll() { while (this.active.length > 0) this.release(this.active[0]); }
Â  Â  }

Â  Â  class OrbitalDefenseGame {
Â  Â  Â  constructor() {
Â  Â  Â  Â  this.canvas = document.getElementById('canvas');
Â  Â  Â  Â  this.ctx = this.canvas.getContext('2d');
Â  Â  Â  Â  this.setupCanvas();

Â  Â  Â  Â  this.gameSpeed = 1;
Â  Â  Â  Â  this.isPaused = false;
Â  Â  Â  Â  this.isGameOver = false;
Â  Â  Â  Â  this.selectedUnit = null;
Â  Â  Â  Â  this.placingUnit = null;

Â  Â  Â  Â  this._raf = null;
Â  Â  Â  Â  this._lastFrame = 0;

Â  Â  Â  Â  this.projectilePool = new ObjectPool(
Â  Â  Â  Â  Â  () => ({ x:0, y:0, vx:0, vy:0, damage:0, color:'#fff', size:3, life:120, explosive:false, piercing:false, chainLightning:false }),
Â  Â  Â  Â  Â  (o) => { o.life = 120; o.explosive = o.piercing = o.chainLightning = false; }
Â  Â  Â  Â  );
Â  Â  Â  Â  this.particlePool = new ObjectPool(
Â  Â  Â  Â  Â  () => ({ x:0, y:0, vx:0, vy:0, life:30, maxLife:30, color:'#fff', size:2 }),
Â  Â  Â  Â  Â  (o) => { o.life = o.maxLife; }
Â  Â  Â  Â  );

Â  Â  Â  Â  this.wave = 1;
Â  Â  Â  Â  this.credits = 1000;
Â  Â  Â  Â  this.score = 0;
Â  Â  Â  Â  this.tower = { x: 0, y: 0, maxHp: 100, hp: 100, radius: 40 };

Â  Â  Â  Â  this.units = [];
Â  Â  Â  Â  this.enemies = [];
Â  Â  Â  Â  this.projectiles = [];
Â  Â  Â  Â  this.particles = [];
Â  Â  Â  Â  this.upgrades = { damageBoost: 0, rangeBoost: 0, fireRateBoost: 0, creditBonus: 0 };

Â  Â  Â  Â  this.achievements = {
Â  Â  Â  Â  Â  firstKill:Â  Â { unlocked: false, name: "First Blood",Â  Â  Â desc: "Destroy your first enemy" },
Â  Â  Â  Â  Â  wave10:Â  Â  Â  { unlocked: false, name: "Veteran",Â  Â  Â  Â  Â desc: "Survive 10 waves" },
Â  Â  Â  Â  Â  wave25:Â  Â  Â  { unlocked: false, name: "Elite",Â  Â  Â  Â  Â  Â desc: "Survive 25 waves" },
Â  Â  Â  Â  Â  score10k:Â  Â  { unlocked: false, name: "High Scorer",Â  Â  Â desc: "Reach 10,000 points" },
Â  Â  Â  Â  Â  firstBoss:Â  Â { unlocked: false, name: "Boss Slayer",Â  Â  Â desc: "Defeat your first boss" },
Â  Â  Â  Â  Â  perfectWave: { unlocked: false, name: "Perfect Defense", desc: "Complete a wave without taking damage" }
Â  Â  Â  Â  };

Â  Â  Â  Â  this.waveTimer = 0;
Â  Â  Â  Â  this.waveDelay = 15000;
Â  Â  Â  Â  this.enemiesPerWave = 8;
Â  Â  Â  Â  this.enemySpawnDelay = 1000;
Â  Â  Â  Â  this.lastEnemySpawn = 0;
Â  Â  Â  Â  this.enemiesSpawned = 0;
Â  Â  Â  Â  this.waveActive = false;
Â  Â  Â  Â  this.waveDamage = 0;
Â  Â  Â  Â  this.bossWave = false;

Â  Â  Â  Â  this.dailyChallenge = this.generateDailyChallenge();

Â  Â  Â  Â  this.unitTypes = {
Â  Â  Â  Â  Â  turret: { name:"PLASMA TURRET", cost:100, damage:15, range:120, fireRate:800, hp:50, color:'#00ffcc', size:20, projectileSpeed:8, unlocked:true },
Â  Â  Â  Â  Â  laser:Â  { name:"LASER CANNON",Â  cost:200, damage:8,Â  range:180, fireRate:150, hp:40, color:'#ff00ff', size:25, projectileSpeed:20, unlocked:false, unlockWave:3 },
Â  Â  Â  Â  Â  missile:{ name:"MISSILE SILO",Â  cost:350, damage:80, range:200, fireRate:2500, hp:60, color:'#ffaa00', size:30, projectileSpeed:4,Â  explosive:true, unlocked:false, unlockWave:5 },
Â  Â  Â  Â  Â  railgun:{ name:"RAILGUN",Â  Â  Â  Â cost:500, damage:150,range:300, fireRate:3000, hp:80, color:'#00aaff', size:35, projectileSpeed:25, piercing:true, unlocked:false, unlockWave:8 },
Â  Â  Â  Â  Â  tesla:Â  { name:"TESLA COIL",Â  Â  cost:600, damage:25, range:100, fireRate:400,Â  hp:100,color:'#aaffff', size:28, projectileSpeed:0,Â  chainLightning:true, unlocked:false, unlockWave:12 }
Â  Â  Â  Â  };

Â  Â  Â  Â  this.enemyTypes = [
Â  Â  Â  Â  Â  { name:"Scout",Â  hp:30,Â  speed:1.5, damage:8,Â  reward:25,Â  color:'#ff6666', size:12 },
Â  Â  Â  Â  Â  { name:"Fighter",hp:60,Â  speed:1.2, damage:15, reward:40,Â  color:'#ff9966', size:16 },
Â  Â  Â  Â  Â  { name:"Heavy",Â  hp:120, speed:0.8, damage:25, reward:70,Â  color:'#ff66ff', size:22 },
Â  Â  Â  Â  Â  { name:"Elite",Â  hp:200, speed:1.0, damage:40, reward:120, color:'#ffff66', size:25 }
Â  Â  Â  Â  ];

Â  Â  Â  Â  this.mouseX = 0;
Â  Â  Â  Â  this.mouseY = 0;

Â  Â  Â  Â  this.setupEventListeners();
Â  Â  Â  Â  this.loadHighScores();
Â  Â  Â  Â  this.loadAchievements();
Â  Â  Â  Â  this.updateUI();

Â  Â  Â  Â  console.log('[ODC] Game created and UI initialized.');
Â  Â  Â  }

Â  Â  Â  setupCanvas() {
Â  Â  Â  Â  const resize = () => {
Â  Â  Â  Â  Â  const container = document.getElementById('gameContainer');
Â  Â  Â  Â  Â  const sidePanel = document.getElementById('sidePanel');
Â  Â  Â  Â  Â  const margins = 40;
Â  Â  Â  Â  Â  this.canvas.widthÂ  = Math.max(200, container.offsetWidth - sidePanel.offsetWidth - margins);
Â  Â  Â  Â  Â  this.canvas.height = Math.max(200, container.offsetHeight - margins);
Â  Â  Â  Â  Â  this.tower.x = this.canvas.width / 2;
Â  Â  Â  Â  Â  this.tower.y = this.canvas.height / 2;
Â  Â  Â  Â  };
Â  Â  Â  Â  resize();
Â  Â  Â  Â  window.addEventListener('resize', resize);
Â  Â  Â  }

Â  Â  Â  setupEventListeners() {
Â  Â  Â  Â  this.canvas.addEventListener('mousemove', (e) => {
Â  Â  Â  Â  Â  const rect = this.canvas.getBoundingClientRect();
Â  Â  Â  Â  Â  this.mouseX = e.clientX - rect.left;
Â  Â  Â  Â  Â  this.mouseY = e.clientY - rect.top;
Â  Â  Â  Â  });
Â  Â  Â  Â  this.canvas.addEventListener('click', () => {
Â  Â  Â  Â  Â  if (this.placingUnit) this.placeUnit(this.mouseX, this.mouseY);
Â  Â  Â  Â  });
Â  Â  Â  Â  this.canvas.addEventListener('contextmenu', (e) => {
Â  Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  Â  this.cancelPlacement();
Â  Â  Â  Â  });
Â  Â  Â  Â  document.addEventListener('keydown', (e) => {
Â  Â  Â  Â  Â  if (e.key === 'Escape') this.cancelPlacement();
Â  Â  Â  Â  Â  if (e.key === ' ' && !this.isGameOver) { e.preventDefault(); this.togglePause(); }
Â  Â  Â  Â  });
Â  Â  Â  }

Â  Â  Â  generateDailyChallenge() {
Â  Â  Â  Â  const today = new Date().toDateString();
Â  Â  Â  Â  const challenges = [
Â  Â  Â  Â  Â  { name: "Speed Run", desc: "Survive 15 waves in under 10 minutes", type: "time" },
Â  Â  Â  Â  Â  { name: "Minimalist", desc: "Beat wave 10 with 5 or fewer units", type: "units" },
Â  Â  Â  Â  Â  { name: "Economy", desc: "Reach 5000 credits", type: "credits" },
Â  Â  Â  Â  Â  { name: "Pacifist", desc: "Beat 5 waves without killing any scouts", type: "pacifist" }
Â  Â  Â  Â  ];
Â  Â  Â  Â  const seed = today.split('').reduce((a, b) => a + b.charCodeAt(0), 0);
Â  Â  Â  Â  return challenges[seed % challenges.length];
Â  Â  Â  }

Â  Â  Â  startNewGame() {
Â  Â  Â  Â  if (this._raf) cancelAnimationFrame(this._raf);
Â  Â  Â  Â  this.wave = 1; this.credits = 1000; this.score = 0;
Â  Â  Â  Â  this.tower.hp = this.tower.maxHp;

Â  Â  Â  Â  this.units = []; this.enemies = [];
Â  Â  Â  Â  this.projectilePool.releaseAll(); this.particlePool.releaseAll();

Â  Â  Â  Â  this.upgrades = { damageBoost:0, rangeBoost:0, fireRateBoost:0, creditBonus:0 };

Â  Â  Â  Â  this.waveTimer = 0; this.enemiesSpawned = 0; this.waveActive = false;
Â  Â  Â  Â  this.isGameOver = false; this.isPaused = false;
Â  Â  Â  Â  this.waveDamage = 0; this.bossWave = false;

Â  Â  Â  Â  document.getElementById('menuOverlay').style.display = 'none';
Â  Â  Â  Â  document.getElementById('gameOverMenu').style.display = 'none';
Â  Â  Â  Â  document.getElementById('pauseMenu').style.display = 'none';

Â  Â  Â  Â  this.setSpeed(1);
Â  Â  Â  Â  this.updateUI();
Â  Â  Â  Â  this._lastFrame = performance.now();
Â  Â  Â  Â  this.gameLoop(this._lastFrame);

Â  Â  Â  Â  console.log('[ODC] New game started.');
Â  Â  Â  }

Â  Â  Â  saveGame() {
Â  Â  Â  Â  const saveData = {
Â  Â  Â  Â  Â  wave: this.wave, credits: this.credits, score: this.score,
Â  Â  Â  Â  Â  tower: { ...this.tower },
Â  Â  Â  Â  Â  units: this.units.map(u => ({ type: u.type, x: u.x, y: u.y, hp: u.hp })),
Â  Â  Â  Â  Â  upgrades: { ...this.upgrades }, timestamp: Date.now()
Â  Â  Â  Â  };
Â  Â  Â  Â  localStorage.setItem('orbitalDefenseSave', JSON.stringify(saveData));
Â  Â  Â  Â  this.showNotification('Game Saved!');
Â  Â  Â  }

Â  Â  Â  loadGame() {
Â  Â  Â  Â  const saveData = localStorage.getItem('orbitalDefenseSave');
Â  Â  Â  Â  if (!saveData) { this.showNotification('No save found!'); return; }
Â  Â  Â  Â  if (this._raf) cancelAnimationFrame(this._raf);

Â  Â  Â  Â  const data = JSON.parse(saveData);
Â  Â  Â  Â  this.wave = data.wave; this.credits = data.credits; this.score = data.score;
Â  Â  Â  Â  this.tower = { ...this.tower, hp: data.tower.hp, maxHp: data.tower.maxHp };
Â  Â  Â  Â  this.upgrades = data.upgrades || { damageBoost:0, rangeBoost:0, fireRateBoost:0, creditBonus:0 };

Â  Â  Â  Â  this.units = (data.units || []).map(u => {
Â  Â  Â  Â  Â  const unitType = this.unitTypes[u.type];
Â  Â  Â  Â  Â  return { ...unitType, type: u.type, x: u.x, y: u.y, hp: u.hp, maxHp: unitType.hp, lastFire: 0 };
Â  Â  Â  Â  });

Â  Â  Â  Â  this.enemies = [];
Â  Â  Â  Â  this.projectilePool.releaseAll(); this.particlePool.releaseAll();

Â  Â  Â  Â  this.waveTimer = 0; this.enemiesSpawned = 0; this.waveActive = false;
Â  Â  Â  Â  this.isGameOver = false; this.isPaused = false; this.waveDamage = 0; this.bossWave = false;

Â  Â  Â  Â  document.getElementById('menuOverlay').style.display = 'none';
Â  Â  Â  Â  this.updateUI();
Â  Â  Â  Â  this._lastFrame = performance.now();
Â  Â  Â  Â  this.gameLoop(this._lastFrame);

Â  Â  Â  Â  console.log('[ODC] Save loaded.');
Â  Â  Â  }

Â  Â  Â  togglePause() {
Â  Â  Â  Â  if (this.isGameOver) return;
Â  Â  Â  Â  this.isPaused = !this.isPaused;
Â  Â  Â  Â  const pauseMenu = document.getElementById('pauseMenu');
Â  Â  Â  Â  const mainMenu = document.getElementById('mainMenu');
Â  Â  Â  Â  const overlay = document.getElementById('menuOverlay');
Â  Â  Â  Â  if (this.isPaused) {
Â  Â  Â  Â  Â  overlay.style.display = 'flex';
Â  Â  Â  Â  Â  pauseMenu.style.display = 'block';
Â  Â  Â  Â  Â  mainMenu.style.display = 'none';
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  overlay.style.display = 'none';
Â  Â  Â  Â  Â  this._lastFrame = performance.now(); // Reset delta time
Â  Â  Â  Â  Â  this.gameLoop(this._lastFrame);
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  returnToMenu() {
Â  Â  Â  Â  this.isPaused = true; this.isGameOver = true;
Â  Â  Â  Â  if (this._raf) cancelAnimationFrame(this._raf);
Â  Â  Â  Â  const pauseMenu = document.getElementById('pauseMenu');
Â  Â  Â  Â  const mainMenu = document.getElementById('mainMenu');
Â  Â  Â  Â  const gameOverMenu = document.getElementById('gameOverMenu');
Â  Â  Â  Â  document.getElementById('menuOverlay').style.display = 'flex';
Â  Â  Â  Â  pauseMenu.style.display = 'none';
Â  Â  Â  Â  gameOverMenu.style.display = 'none';
Â  Â  Â  Â  mainMenu.style.display = 'block';
Â  Â  Â  Â  this.loadHighScores();
Â  Â  Â  }

Â  Â  Â  setSpeed(speed) {
Â  Â  Â  Â  this.gameSpeed = speed;
Â  Â  Â  Â  document.querySelectorAll('.speed-button').forEach(btn => {
Â  Â  Â  Â  Â  const val = parseInt(btn.getAttribute('data-speed'), 10);
Â  Â  Â  Â  Â  if (val === speed) btn.classList.add('active'); else btn.classList.remove('active');
Â  Â  Â  Â  });
Â  Â  Â  }

Â  Â  Â  selectUnit(type) {
Â  Â  Â  Â  const unitType = this.unitTypes[type];
Â  Â  Â  Â  if (!unitType.unlocked) { this.showNotification(`Unlocks at wave ${unitType.unlockWave}`); return; }
Â  Â  Â  Â  if (this.credits < unitType.cost) { this.showNotification('Insufficient credits!'); return; }
Â  Â  Â  Â  this.placingUnit = type;
Â  Â  Â  Â  document.querySelectorAll('.unit-card').forEach(c => c.classList.remove('selected'));
Â  Â  Â  Â  const card = document.querySelector(`[data-unit="${type}"]`);
Â  Â  Â  Â  if (card) card.classList.add('selected');
Â  Â  Â  }

Â  Â  Â  cancelPlacement() {
Â  Â  Â  Â  this.placingUnit = null;
Â  Â  Â  Â  document.querySelectorAll('.unit-card').forEach(c => c.classList.remove('selected'));
Â  Â  Â  }

Â  Â  Â  placeUnit(x, y) {
Â  Â  Â  Â  if (!this.placingUnit) return;
Â  Â  Â  Â  const unitType = this.unitTypes[this.placingUnit];

Â  Â  Â  Â  const distToTower = Math.hypot(x - this.tower.x, y - this.tower.y);
Â  Â  Â  Â  if (distToTower < this.tower.radius + unitType.size + 20) { this.showNotification('Too close to tower!'); return; }

Â  Â  Â  Â  for (let unit of this.units) {
Â  Â  Â  Â  Â  const d = Math.hypot(x - unit.x, y - unit.y);
Â  Â  Â  Â  Â  if (d < unit.size + unitType.size + 10) { this.showNotification('Too close to another unit!'); return; }
Â  Â  Â  Â  }

Â  Â  Â  Â  this.credits -= unitType.cost;
Â  Â  Â  Â  this.units.push({
Â  Â  Â  Â  Â  ...unitType, type: this.placingUnit, x, y,
Â  Â  Â  Â  Â  hp: unitType.hp, maxHp: unitType.hp, lastFire: 0
Â  Â  Â  Â  });

Â  Â  Â  Â  this.cancelPlacement();
Â  Â  Â  Â  this.updateUI();
Â  Â  Â  Â  this.createParticles(x, y, unitType.color, 10);
Â  Â  Â  }

Â  Â  Â  spawnEnemy() {
Â  Â  Â  Â  const waveMultiplier = Math.pow(1.12, this.wave - 1);
Â  Â  Â  Â  const idx = Math.min(Math.floor(Math.random() * (1 + this.wave / 4)), this.enemyTypes.length - 1);
Â  Â  Â  Â  const base = this.enemyTypes[idx];

Â  Â  Â  Â  const edge = Math.random() * 4;
Â  Â  Â  Â  let x, y;
Â  Â  Â  Â  if (edge < 1) { x = Math.random() * this.canvas.width; y = -base.size; }
Â  Â  Â  Â  else if (edge < 2) { x = this.canvas.width + base.size; y = Math.random() * this.canvas.height; }
Â  Â  Â  Â  else if (edge < 3) { x = Math.random() * this.canvas.width; y = this.canvas.height + base.size; }
Â  Â  Â  Â  else { x = -base.size; y = Math.random() * this.canvas.height; }

Â  Â  Â  Â  this.enemies.push({
Â  Â  Â  Â  Â  x, y,
Â  Â  Â  Â  Â  hp: Math.floor(base.hp * waveMultiplier),
Â  Â  Â  Â  Â  maxHp: Math.floor(base.hp * waveMultiplier),
Â  Â  Â  Â  Â  speed: base.speed * (1 + this.wave * 0.015),
Â  Â  Â  Â  Â  damage: Math.floor(base.damage * waveMultiplier),
Â  Â  Â  Â  Â  reward: Math.floor(base.reward * (1 + this.upgrades.creditBonus * 0.1)),
Â  Â  Â  Â  Â  color: base.color, size: base.size, type: base.name
Â  Â  Â  Â  });
Â  Â  Â  }

Â  Â  Â  spawnBoss() {
Â  Â  Â  Â  const bossMultiplier = Math.pow(1.3, Math.floor(this.wave / 10));
Â  Â  Â  Â  const x = this.canvas.width / 2, y = -50;
Â  Â  Â  Â  this.enemies.push({
Â  Â  Â  Â  Â  x, y, hp: Math.floor(1000 * bossMultiplier), maxHp: Math.floor(1000 * bossMultiplier),
Â  Â  Â  Â  Â  speed: 0.5, damage: Math.floor(100 * bossMultiplier), reward: Math.floor(500 * bossMultiplier),
Â  Â  Â  Â  Â  color: '#ff0000', size: 50, type: 'Boss', isBoss: true
Â  Â  Â  Â  });
Â  Â  Â  Â  this.showBossWarning();
Â  Â  Â  }

Â  Â  Â  showBossWarning() {
Â  Â  Â  Â  const warning = document.createElement('div');
Â  Â  Â  Â  warning.className = 'boss-warning';
Â  Â  Â  Â  warning.textContent = 'BOSS INCOMING!';
Â  Â  Â  Â  document.body.appendChild(warning);
Â  Â  Â  Â  setTimeout(() => document.body.removeChild(warning), 3000);
Â  Â  Â  }

Â  Â  Â  startWave() {
Â  Â  Â  Â  this.waveActive = true;
Â  Â  Â  Â  this.enemiesSpawned = 0;
Â  Â  Â  Â  this.lastEnemySpawn = 0;
Â  Â  Â  Â  this.waveDamage = 0;

Â  Â  Â  Â  Object.keys(this.unitTypes).forEach(type => {
Â  Â  Â  Â  Â  const unit = this.unitTypes[type];
Â  Â  Â  Â  Â  if (unit.unlockWave && this.wave >= unit.unlockWave && !unit.unlocked) {
Â  Â  Â  Â  Â  Â  unit.unlocked = true;
Â  Â  Â  Â  Â  Â  this.showNotification(`${unit.name} unlocked!`);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });

Â  Â  Â  Â  this.bossWave = (this.wave % 10 === 0);
Â  Â  Â  Â  if (this.bossWave) {
Â  Â  Â  Â  Â  this.enemiesPerWave = 1;
Â  Â  Â  Â  Â  this.spawnBoss();
Â  Â  Â  Â  Â  this.enemiesSpawned = 1;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  this.enemiesPerWave = Math.floor(8 + this.wave * 1.5);
Â  Â  Â  Â  }

Â  Â  Â  Â  this.updateUI();
Â  Â  Â  }

Â  Â  Â  endWave() {
Â  Â  Â  Â  this.waveActive = false;
Â  Â  Â  Â  this.waveTimer = 0;
Â  Â  Â  Â  this.wave++;

Â  Â  Â  Â  const bonus = Math.floor(50 + this.wave * 10);
Â  Â  Â  Â  this.credits += bonus;
Â  Â  Â  Â  this.score += bonus * 2;

Â  Â  Â  Â  if (this.waveDamage === 0 && this.wave > 1) this.unlockAchievement('perfectWave');
Â  Â  Â  Â  if (this.wave === 10) this.unlockAchievement('wave10');
Â  Â  Â  Â  if (this.wave === 25) this.unlockAchievement('wave25');

Â  Â  Â  Â  this.showNotification(`Wave ${this.wave - 1} Complete! +${bonus} credits`);
Â  Â  Â  Â  this.updateUI();
Â  Â  Â  }

Â  Â  Â  updateGame(delta) {
Â  Â  Â  Â  if (this.isGameOver) return;
Â  Â  Â  Â  const dt = delta * this.gameSpeed;

Â  Â  Â  Â  if (!this.waveActive) {
Â  Â  Â  Â  Â  this.waveTimer += dt;
Â  Â  Â  Â  Â  if (this.waveTimer >= this.waveDelay) this.startWave();
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  if (!this.bossWave && this.enemiesSpawned < this.enemiesPerWave) {
Â  Â  Â  Â  Â  Â  this.lastEnemySpawn += dt;
Â  Â  Â  Â  Â  Â  if (this.lastEnemySpawn >= this.enemySpawnDelay) {
Â  Â  Â  Â  Â  Â  Â  this.spawnEnemy();
Â  Â  Â  Â  Â  Â  Â  this.enemiesSpawned++;
Â  Â  Â  Â  Â  Â  Â  this.lastEnemySpawn = 0;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  if (this.enemiesSpawned >= this.enemiesPerWave && this.enemies.length === 0) {
Â  Â  Â  Â  Â  Â  this.endWave();
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  for (let i = this.enemies.length - 1; i >= 0; i--) {
Â  Â  Â  Â  Â  const enemy = this.enemies[i];
Â  Â  Â  Â  Â  const dx = this.tower.x - enemy.x;
Â  Â  Â  Â  Â  const dy = this.tower.y - enemy.y;
Â  Â  Â  Â  Â  const dist = Math.hypot(dx, dy);

Â  Â  Â  Â  Â  if (dist > this.tower.radius + enemy.size) {
Â  Â  Â  Â  Â  Â  enemy.x += (dx / dist) * enemy.speed * (dt / 16.67);
Â  Â  Â  Â  Â  Â  enemy.y += (dy / dist) * enemy.speed * (dt / 16.67);
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  this.tower.hp -= enemy.damage;
Â  Â  Â  Â  Â  Â  this.waveDamage += enemy.damage;
Â  Â  Â  Â  Â  Â  this.createParticles(enemy.x, enemy.y, '#ff0000', 20);
Â  Â  Â  Â  Â  Â  this.enemies.splice(i, 1);
Â  Â  Â  Â  Â  Â  if (this.tower.hp <= 0) { this.tower.hp = 0; this.gameOver(); }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  for (let unit of this.units) {
Â  Â  Â  Â  Â  unit.lastFire += dt;
Â  Â  Â  Â  Â  const effectiveFireRate = unit.fireRate * (1 - this.upgrades.fireRateBoost * 0.1);
Â  Â  Â  Â  Â  const effectiveRange = unit.range * (1 + this.upgrades.rangeBoost * 0.1);

Â  Â  Â  Â  Â  if (unit.lastFire >= effectiveFireRate) {
Â  Â  Â  Â  Â  Â  let target = null;
Â  Â  Â  Â  Â  Â  let minDist = effectiveRange;
Â  Â  Â  Â  Â  Â  for (let enemy of this.enemies) {
Â  Â  Â  Â  Â  Â  Â  const d = Math.hypot(enemy.x - unit.x, enemy.y - unit.y);
Â  Â  Â  Â  Â  Â  Â  if (d < minDist) { target = enemy; minDist = d; }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (target) { this.fireProjectile(unit, target); unit.lastFire = 0; }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  this.projectiles = this.projectilePool.active; // Use active pool directly
Â  Â  Â  Â  for (let i = this.projectiles.length - 1; i >= 0; i--) {
Â  Â  Â  Â  Â  const p = this.projectiles[i];
Â  Â  Â  Â  Â  p.x += p.vx * (dt / 16.67);
Â  Â  Â  Â  Â  p.y += p.vy * (dt / 16.67);
Â  Â  Â  Â  Â  p.life -= dt/16.67;
Â  Â  Â  Â  Â  if (p.life <= 0) { this.projectilePool.release(p); continue; }

Â  Â  Â  Â  Â  for (let j = this.enemies.length - 1; j >= 0; j--) {
Â  Â  Â  Â  Â  Â  const e = this.enemies[j];
Â  Â  Â  Â  Â  Â  const d = Math.hypot(p.x - e.x, p.y - e.y);
Â  Â  Â  Â  Â  Â  if (d < e.size + p.size) {
Â  Â  Â  Â  Â  Â  Â  if (p.explosive) this.handleExplosion(p.x, p.y, p.damage);
Â  Â  Â  Â  Â  Â  Â  else if (p.piercing) this.damageEnemy(e, p.damage);
Â  Â  Â  Â  Â  Â  Â  else if (p.chainLightning) this.handleChainLightning(e, p.damage, 3, [e]);
Â  Â  Â  Â  Â  Â  Â  else this.damageEnemy(e, p.damage);

Â  Â  Â  Â  Â  Â  Â  if (!p.piercing) {
Â  Â  Â  Â  Â  Â  Â  Â  this.projectilePool.release(p);
Â  Â  Â  Â  Â  Â  Â  Â  break; // Projectile is used up
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  this.particles = this.particlePool.active; // Use active pool directly
Â  Â  Â  Â  for (let i = this.particles.length - 1; i >= 0; i--) {
Â  Â  Â  Â  Â  const part = this.particles[i];
Â  Â  Â  Â  Â  part.x += part.vx * (dt / 16.67);
Â  Â  Â  Â  Â  part.y += part.vy * (dt / 16.67);
Â  Â  Â  Â  Â  part.life -= dt/16.67;
Â  Â  Â  Â  Â  if (part.life <= 0) { this.particlePool.release(part); }
Â  Â  Â  Â  }

Â  Â  Â  Â  this.updateUI();
Â  Â  Â  }

Â  Â  Â  fireProjectile(unit, target) {
Â  Â  Â  Â  const dx = target.x - unit.x;
Â  Â  Â  Â  const dy = target.y - unit.y;
Â  Â  Â  Â  const dist = Math.hypot(dx, dy) || 1;

Â  Â  Â  Â  if (unit.chainLightning) {
Â  Â  Â  Â  Â  this.handleChainLightning(target, unit.damage, 3, [target]);
Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  const proj = this.projectilePool.get();
Â  Â  Â  Â  proj.x = unit.x; proj.y = unit.y;
Â  Â  Â  Â  proj.vx = (dx / dist) * unit.projectileSpeed;
Â  Â  Â  Â  proj.vy = (dy / dist) * unit.projectileSpeed;
Â  Â  Â  Â  proj.damage = Math.round(unit.damage * (1 + this.upgrades.damageBoost * 0.1));
Â  Â  Â  Â  proj.color = unit.color;
Â  Â  Â  Â  proj.size = unit.name.includes('MISSILE') ? 6 : 3;
Â  Â  Â  Â  proj.explosive = !!unit.explosive;
Â  Â  Â  Â  proj.piercing = !!unit.piercing;
Â  Â  Â  Â  proj.chainLightning = !!unit.chainLightning;
Â  Â  Â  }

Â  Â  Â  damageEnemy(enemy, damage) {
Â  Â  Â  Â  enemy.hp -= damage;
Â  Â  Â  Â  this.createParticles(enemy.x, enemy.y, enemy.color, 5);
Â  Â  Â  Â  if (enemy.hp <= 0) {
Â  Â  Â  Â  Â  this.credits += enemy.reward;
Â  Â  Â  Â  Â  this.score += enemy.reward * 2;
Â  Â  Â  Â  Â  if (this.score >= 10000) this.unlockAchievement('score10k');
Â  Â  Â  Â  Â  if (enemy.isBoss) this.unlockAchievement('firstBoss');
Â  Â  Â  Â  Â  if (!this.achievements.firstKill.unlocked) this.unlockAchievement('firstKill');
Â  Â  Â  Â  Â  this.createParticles(enemy.x, enemy.y, '#ffaa00', 15);
Â  Â  Â  Â  Â  const idx = this.enemies.indexOf(enemy);
Â  Â  Â  Â  Â  if (idx > -1) this.enemies.splice(idx, 1);
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  handleExplosion(x, y, damage) {
Â  Â  Â  Â  this.createParticles(x, y, '#ffaa00', 25, 80);
Â  Â  Â  Â  for (let enemy of this.enemies) {
Â  Â  Â  Â  Â  const d = Math.hypot(enemy.x - x, enemy.y - y);
Â  Â  Â  Â  Â  if (d < 80) {
Â  Â  Â  Â  Â  Â  const explosionDamage = Math.max(1, Math.round(damage * (1 - d / 80)));
Â  Â  Â  Â  Â  Â  this.damageEnemy(enemy, explosionDamage);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  handleChainLightning(startEnemy, damage, chains, hitEnemies) {
Â  Â  Â  Â  this.damageEnemy(startEnemy, damage);
Â  Â  Â  Â  if (chains <= 0) return;

Â  Â  Â  Â  let closest = null;
Â  Â  Â  Â  let minDist = 150;
Â  Â  Â  Â  for (let enemy of this.enemies) {
Â  Â  Â  Â  Â  if (!hitEnemies.includes(enemy)) {
Â  Â  Â  Â  Â  Â  const d = Math.hypot(enemy.x - startEnemy.x, enemy.y - startEnemy.y);
Â  Â  Â  Â  Â  Â  if (d < minDist) { closest = enemy; minDist = d; }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  if (closest) {
Â  Â  Â  Â  Â  this.createLightningEffect(startEnemy.x, startEnemy.y, closest.x, closest.y);
Â  Â  Â  Â  Â  hitEnemies.push(closest);
Â  Â  Â  Â  Â  this.handleChainLightning(closest, damage * 0.7, chains - 1, hitEnemies);
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  // FIX: Added missing and incomplete methods from here down
Â  Â  Â  createLightningEffect(x1, y1, x2, y2) {
Â  Â  Â  Â  const lightning = this.particlePool.get();
Â  Â  Â  Â  lightning.isLightning = true;
Â  Â  Â  Â  lightning.x1 = x1; lightning.y1 = y1;
Â  Â  Â  Â  lightning.x2 = x2; lightning.y2 = y2;
Â  Â  Â  Â  lightning.life = 10;
Â  Â  Â  Â  this.particles.push(lightning);
Â  Â  Â  }

Â  Â  Â  createParticles(x, y, color, count, radius = 5) {
Â  Â  Â  Â  for (let i = 0; i < count; i++) {
Â  Â  Â  Â  Â  const p = this.particlePool.get();
Â  Â  Â  Â  Â  const angle = Math.random() * Math.PI * 2;
Â  Â  Â  Â  Â  const speed = Math.random() * 3 + 1;
Â  Â  Â  Â  Â  p.x = x; p.y = y;
Â  Â  Â  Â  Â  p.vx = Math.cos(angle) * speed;
Â  Â  Â  Â  Â  p.vy = Math.sin(angle) * speed;
Â  Â  Â  Â  Â  p.color = color;
Â  Â  Â  Â  Â  p.life = Math.random() * 20 + 20;
Â  Â  Â  Â  Â  p.maxLife = p.life;
Â  Â  Â  Â  Â  p.size = Math.random() * 2 + 1;
Â  Â  Â  Â  Â  p.isLightning = false;
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  gameLoop(timestamp) {
Â  Â  Â  Â  if (this.isPaused || this.isGameOver) return;
Â  Â  Â  Â  const delta = timestamp - this._lastFrame;
Â  Â  Â  Â  this._lastFrame = timestamp;

Â  Â  Â  Â  this.updateGame(delta);
Â  Â  Â  Â  this.drawGame();

Â  Â  Â  Â  this._raf = requestAnimationFrame(this.gameLoop.bind(this));
Â  Â  Â  }

Â  Â  Â  drawGame() {
Â  Â  Â  Â  this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

Â  Â  Â  Â  // Draw Tower
Â  Â  Â  Â  this.ctx.fillStyle = '#00ffcc';
Â  Â  Â  Â  this.ctx.beginPath();
Â  Â  Â  Â  this.ctx.arc(this.tower.x, this.tower.y, this.tower.radius, 0, Math.PI * 2);
Â  Â  Â  Â  this.ctx.fill();
Â  Â  Â  Â  this.ctx.strokeStyle = '#009988'; this.ctx.lineWidth = 3;
Â  Â  Â  Â  this.ctx.stroke();

Â  Â  Â  Â  // Draw Units
Â  Â  Â  Â  this.units.forEach(u => {
Â  Â  Â  Â  Â  this.ctx.fillStyle = u.color;
Â  Â  Â  Â  Â  this.ctx.beginPath();
Â  Â  Â  Â  Â  this.ctx.arc(u.x, u.y, u.size, 0, Math.PI * 2);
Â  Â  Â  Â  Â  this.ctx.fill();
Â  Â  Â  Â  });

Â  Â  Â  Â  // Draw Enemies
Â  Â  Â  Â  this.enemies.forEach(e => {
Â  Â  Â  Â  Â  this.ctx.fillStyle = e.color;
Â  Â  Â  Â  Â  this.ctx.beginPath();
Â  Â  Â  Â  Â  this.ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
Â  Â  Â  Â  Â  this.ctx.fill();
Â  Â  Â  Â  Â  // Health bar
Â  Â  Â  Â  Â  const hpWidth = (e.hp / e.maxHp) * e.size * 2;
Â  Â  Â  Â  Â  this.ctx.fillStyle = '#ff0000';
Â  Â  Â  Â  Â  this.ctx.fillRect(e.x - e.size, e.y - e.size - 8, e.size*2, 4);
Â  Â  Â  Â  Â  this.ctx.fillStyle = '#00ff00';
Â  Â  Â  Â  Â  this.ctx.fillRect(e.x - e.size, e.y - e.size - 8, hpWidth, 4);
Â  Â  Â  Â  });

Â  Â  Â  Â  // Draw Projectiles
Â  Â  Â  Â  this.projectiles.forEach(p => {
Â  Â  Â  Â  Â  this.ctx.fillStyle = p.color;
Â  Â  Â  Â  Â  this.ctx.beginPath();
Â  Â  Â  Â  Â  this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
Â  Â  Â  Â  Â  this.ctx.fill();
Â  Â  Â  Â  });

Â  Â  Â  Â  // Draw Particles
Â  Â  Â  Â  this.particles.forEach(p => {
Â  Â  Â  Â  Â  if (p.isLightning) {
Â  Â  Â  Â  Â  Â  this.ctx.strokeStyle = '#aaffff'; this.ctx.lineWidth = 2;
Â  Â  Â  Â  Â  Â  this.ctx.globalAlpha = p.life / 10;
Â  Â  Â  Â  Â  Â  this.ctx.beginPath(); this.ctx.moveTo(p.x1, p.y1); this.ctx.lineTo(p.x2, p.y2); this.ctx.stroke();
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  this.ctx.globalAlpha = p.life / p.maxLife;
Â  Â  Â  Â  Â  Â  this.ctx.fillStyle = p.color;
Â  Â  Â  Â  Â  Â  this.ctx.beginPath();
Â  Â  Â  Â  Â  Â  this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  this.ctx.fill();
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  Â  this.ctx.globalAlpha = 1.0;

Â  Â  Â  Â  // Draw placement guide
Â  Â  Â  Â  if (this.placingUnit) {
Â  Â  Â  Â  Â  const unitType = this.unitTypes[this.placingUnit];
Â  Â  Â  Â  Â  this.ctx.strokeStyle = unitType.color;
Â  Â  Â  Â  Â  this.ctx.globalAlpha = 0.5;
Â  Â  Â  Â  Â  this.ctx.lineWidth = 2;
Â  Â  Â  Â  Â  this.ctx.beginPath();
Â  Â  Â  Â  Â  this.ctx.arc(this.mouseX, this.mouseY, unitType.size, 0, Math.PI * 2);
Â  Â  Â  Â  Â  this.ctx.stroke();
Â  Â  Â  Â  Â  this.ctx.setLineDash([5, 5]);
Â  Â  Â  Â  Â  this.ctx.beginPath();
Â  Â  Â  Â  Â  this.ctx.arc(this.mouseX, this.mouseY, unitType.range, 0, Math.PI * 2);
Â  Â  Â  Â  Â  this.ctx.stroke();
Â  Â  Â  Â  Â  this.ctx.setLineDash([]);
Â  Â  Â  Â  Â  this.ctx.globalAlpha = 1.0;
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  updateUI() {
Â  Â  Â  Â  document.getElementById('waveCount').textContent = this.wave;
Â  Â  Â  Â  document.getElementById('credits').textContent = this.credits;
Â  Â  Â  Â  document.getElementById('score').textContent = this.score;
Â  Â  Â  Â  document.getElementById('towerHp').textContent = `${Math.max(0, this.tower.hp)}/${this.tower.maxHp}`;
Â  Â  Â  Â  document.getElementById('towerHp').parentElement.classList.toggle('warning-flash', this.tower.hp < this.tower.maxHp * 0.3);

Â  Â  Â  Â  const timerEl = document.getElementById('waveTimer');
Â  Â  Â  Â  if (!this.waveActive) {
Â  Â  Â  Â  Â  timerEl.style.display = 'block';
Â  Â  Â  Â  Â  const timeLeft = Math.ceil((this.waveDelay - this.waveTimer) / 1000);
Â  Â  Â  Â  Â  timerEl.textContent = `WAVE ${this.wave} IN: ${timeLeft}s`;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  timerEl.style.display = 'none';
Â  Â  Â  Â  }

Â  Â  Â  Â  // Update side panel
Â  Â  Â  Â  const unitSelection = document.getElementById('unitSelection');
Â  Â  Â  Â  unitSelection.innerHTML = Object.entries(this.unitTypes).map(([key, u]) => `
Â  Â  Â  Â  Â  <div class="unit-card ${this.credits < u.cost ? 'disabled' : ''} ${!u.unlocked ? 'disabled' : ''}" data-unit="${key}">
Â  Â  Â  Â  Â  Â  <div class="unit-name">${u.name} ${!u.unlocked ? `(WAVE ${u.unlockWave})` : ''}</div>
Â  Â  Â  Â  Â  Â  <div class="unit-stats">DMG: ${u.damage} | RNG: ${u.range} | RATE: ${u.fireRate}ms</div>
Â  Â  Â  Â  Â  Â  <div class="unit-cost">COST: ${u.cost}c</div>
Â  Â  Â  Â  Â  </div>`).join('');
Â  Â  Â  Â  unitSelection.querySelectorAll('.unit-card').forEach(card => {
Â  Â  Â  Â  Â  card.addEventListener('click', () => this.selectUnit(card.dataset.unit));
Â  Â  Â  Â  });
Â  Â  Â  }

Â  Â  Â  gameOver() {
Â  Â  Â  Â  this.isGameOver = true;
Â  Â  Â  Â  if (this._raf) cancelAnimationFrame(this._raf);
Â  Â  Â  Â  console.log('[ODC] Game Over. Final Score:', this.score);

Â  Â  Â  Â  this.saveHighScore(this.score);
Â  Â  Â  Â  document.getElementById('menuOverlay').style.display = 'flex';
Â  Â  Â  Â  document.getElementById('gameOverMenu').style.display = 'block';
Â  Â  Â  Â  document.getElementById('mainMenu').style.display = 'none';
Â  Â  Â  Â  document.getElementById('pauseMenu').style.display = 'none';
Â  Â  Â  Â  document.getElementById('finalScore').textContent = `FINAL SCORE: ${this.score}`;
Â  Â  Â  }

Â  Â  Â  showNotification(message) {
Â  Â  Â  Â  const note = document.createElement('div');
Â  Â  Â  Â  note.className = 'notification';
Â  Â  Â  Â  note.textContent = message;
Â  Â  Â  Â  document.body.appendChild(note);
Â  Â  Â  Â  setTimeout(() => document.body.removeChild(note), 3000);
Â  Â  Â  }

Â  Â  Â  unlockAchievement(key) {
Â  Â  Â  Â  if (this.achievements[key] && !this.achievements[key].unlocked) {
Â  Â  Â  Â  Â  this.achievements[key].unlocked = true;
Â  Â  Â  Â  Â  const achievement = document.createElement('div');
Â  Â  Â  Â  Â  achievement.className = 'achievement';
Â  Â  Â  Â  Â  achievement.textContent = `ðŸ† Achievement Unlocked: ${this.achievements[key].name}`;
Â  Â  Â  Â  Â  document.body.appendChild(achievement);
Â  Â  Â  Â  Â  setTimeout(() => document.body.removeChild(achievement), 3000);
Â  Â  Â  Â  Â  this.saveAchievements();
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  saveAchievements() {
Â  Â  Â  Â  const unlocked = {};
Â  Â  Â  Â  for(const key in this.achievements) { if(this.achievements[key].unlocked) unlocked[key] = true; }
Â  Â  Â  Â  localStorage.setItem('orbitalDefenseAchievements', JSON.stringify(unlocked));
Â  Â  Â  }
Â  Â  Â  loadAchievements() {
Â  Â  Â  Â  const unlocked = JSON.parse(localStorage.getItem('orbitalDefenseAchievements') || '{}');
Â  Â  Â  Â  for(const key in unlocked) { if(this.achievements[key]) this.achievements[key].unlocked = true; }
Â  Â  Â  }

Â  Â  Â  saveHighScore(score) {
Â  Â  Â  Â  const scores = this.getHighScores();
Â  Â  Â  Â  scores.push(score);
Â  Â  Â  Â  scores.sort((a,b) => b-a);
Â  Â  Â  Â  localStorage.setItem('orbitalDefenseHighScores', JSON.stringify(scores.slice(0, 5)));
Â  Â  Â  Â  this.loadHighScores();
Â  Â  Â  }
Â  Â  Â  getHighScores() {
Â  Â  Â  Â  return JSON.parse(localStorage.getItem('orbitalDefenseHighScores') || '[]');
Â  Â  Â  }
Â  Â  Â  loadHighScores() {
Â  Â  Â  Â  const scores = this.getHighScores();
Â  Â  Â  Â  const listEl = document.getElementById('highScoresList');
Â  Â  Â  Â  if (scores.length === 0) {
Â  Â  Â  Â  Â  listEl.innerHTML = '<p style="color: #8899aa;">No missions logged.</p>';
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  listEl.innerHTML = scores.map((score, i) => `
Â  Â  Â  Â  Â  Â  <div class="high-score-item">
Â  Â  Â  Â  Â  Â  Â  <span>#${i+1} Commander</span>
Â  Â  Â  Â  Â  Â  Â  <span>${score.toLocaleString()} PTS</span>
Â  Â  Â  Â  Â  Â  </div>`).join('');
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  } // End of OrbitalDefenseGame Class

Â  Â  // --- Game Initialization ---
Â  Â  const game = new OrbitalDefenseGame();

Â  Â  // FIX: Added the missing event listeners for all menu buttons
Â  Â  document.getElementById('newGameBtn').addEventListener('click', () => game.startNewGame());
Â  Â  document.getElementById('continueBtn').addEventListener('click', () => game.loadGame());
Â  Â  document.getElementById('pauseBtn').addEventListener('click', () => game.togglePause());
Â  Â  document.getElementById('resumeBtn').addEventListener('click', () => game.togglePause());
Â  Â  document.getElementById('saveBtn').addEventListener('click', () => game.saveGame());
Â  Â  document.getElementById('saveProgressBtn').addEventListener('click', () => game.saveGame());
Â  Â  document.getElementById('menuBtn').addEventListener('click', () => game.returnToMenu());
Â  Â  document.getElementById('abandonBtn').addEventListener('click', () => game.returnToMenu());
Â  Â  document.getElementById('newMissionBtn').addEventListener('click', () => game.startNewGame());
Â  Â  document.getElementById('mainMenuBtn').addEventListener('click', () => game.returnToMenu());

Â  Â  document.querySelectorAll('.speed-button').forEach(btn => {
Â  Â  Â  btn.addEventListener('click', () => game.setSpeed(parseInt(btn.getAttribute('data-speed'), 10)));
Â  Â  });

Â  })();
Â  </script>
</body>
</html>
