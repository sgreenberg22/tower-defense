<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ORBITAL DEFENSE COMMAND</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%); color: #fff; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
    #header { background: rgba(0, 0, 0, 0.8); padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid #00ffcc; box-shadow: 0 2px 20px rgba(0, 255, 204, 0.3); }
    .stat-display { display: flex; gap: 30px; font-size: 18px; font-weight: bold; }
    .stat-item { color: #00ffcc; text-shadow: 0 0 10px rgba(0, 255, 204, 0.5); }
    .stat-label { color: #8899aa; margin-right: 5px; }
    #gameContainer { flex: 1; display: flex; position: relative; }
    #canvas { background: radial-gradient(ellipse at center, #1a2332 0%, #0a0e1a 100%); border: 2px solid #00ffcc; box-shadow: 0 0 50px rgba(0, 255, 204, 0.2); margin: 20px; }
    #sidePanel { width: 350px; background: rgba(0, 0, 0, 0.9); padding: 20px; overflow-y: auto; border-left: 2px solid #00ffcc; display: flex; flex-direction: column;}
    .panel-section { margin-bottom: 25px; padding: 15px; background: rgba(26, 31, 58, 0.5); border-radius: 8px; border: 1px solid rgba(0, 255, 204, 0.3);}
    .section-title { font-size: 20px; color: #00ffcc; margin-bottom: 15px; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 15px rgba(0, 255, 204, 0.7); }
    .unit-card { background: rgba(0, 255, 204, 0.1); border: 1px solid #00ffcc; padding: 12px; margin-bottom: 12px; border-radius: 5px; cursor: pointer; transition: all 0.3s ease; }
    .unit-card:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0, 255, 204, 0.4); }
    .unit-card.disabled { opacity: 0.5; cursor: not-allowed; }
    .unit-name { font-size: 16px; font-weight: bold; color: #fff; margin-bottom: 5px; }
    .unit-stats { font-size: 12px; color: #8899aa; line-height: 1.5; }
    .unit-cost { font-size: 14px; color: #ffaa00; font-weight: bold; margin-top: 5px; }
    .game-button { background: linear-gradient(135deg, #00ffcc, #0099ff); border: none; color: #000; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; margin-top: 5px; }
    .game-button.secondary { background: transparent; border: 2px solid #00ffcc; color: #00ffcc; }
    #waveTimer { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); font-size: 24px; color: #ffaa00; font-weight: bold; text-shadow: 0 0 20px rgba(255, 170, 0, 0.8); background: rgba(0, 0, 0, 0.8); padding: 10px 20px; border-radius: 8px; border: 2px solid #ffaa00; }
    #pauseOverlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); display: none; justify-content: center; align-items: center; z-index: 1000; font-size: 72px; color: #00ffcc; text-shadow: 0 0 30px #00ffcc; }
  </style>
</head>
<body>
  <div id="header">
    <div class="stat-display">
      <div class="stat-item"><span class="stat-label">WAVE:</span><span id="waveCount">1</span></div>
      <div class="stat-item"><span class="stat-label">CREDITS:</span><span id="credits">1000</span></div>
      <div class="stat-item"><span class="stat-label">SCORE:</span><span id="score">0</span></div>
      <div class="stat-item"><span class="stat-label">TOWER HP:</span><span id="towerHp">100/100</span></div>
    </div>
    <button id="pauseBtn" class="game-button">Pause</button>
  </div>

  <div id="gameContainer">
    <canvas id="canvas"></canvas>
    <div id="waveTimer"></div>
    <div id="pauseOverlay">PAUSED</div>
    <div id="sidePanel">
      <div class="panel-section">
        <div class="section-title">Deploy Units</div>
        <div id="unitSelection"></div>
      </div>
      <div class="panel-section" style="margin-top: auto;">
        <div class="section-title">Mission Control</div>
        <button id="saveBtn" class="game-button">Save Progress</button>
        <button id="loadBtn" class="game-button secondary">Load Last Save</button>
      </div>
    </div>
  </div>

<script>
(function () {
  class OrbitalDefenseGame {
    constructor() {
      this.canvas = document.getElementById('canvas');
      this.ctx = this.canvas.getContext('2d');
      this.setupCanvas();

      this._raf = null;
      this._lastFrame = 0;
      this.isPaused = false;
      this.isGameOver = false;

      this.resetGameState();
      
      this.unitTypes = {
        turret: { name:"PLASMA TURRET", cost:100, damage:15, range:120, fireRate:800, color:'#00ffcc', size:20, projectileSpeed:8 },
        laser:  { name:"LASER CANNON",  cost:200, damage:8,  range:180, fireRate:150, color:'#ff00ff', size:25, projectileSpeed:20 },
      };

      this.enemyTypes = [
        { name:"Scout",   hp:30,  speed:1.5, damage:8,  reward:25,  color:'#ff6666', size:12 },
        { name:"Fighter", hp:60,  speed:1.2, damage:15, reward:40,  color:'#ff9966', size:16 },
      ];

      this.setupEventListeners();
      this.startNewGame(); // FIX: Game starts automatically
    }

    resetGameState() {
      this.wave = 1; this.credits = 1000; this.score = 0;
      this.tower = { x: this.canvas.width / 2, y: this.canvas.height / 2, maxHp: 100, hp: 100, radius: 40 };
      this.units = []; this.enemies = []; this.projectiles = [];
      this.placingUnit = null; this.waveTimer = 0; this.waveDelay = 15000;
      this.enemiesPerWave = 8; this.enemySpawnDelay = 1000;
      this.lastEnemySpawn = 0; this.enemiesSpawned = 0; this.waveActive = false;
    }

    setupCanvas() {
      const resize = () => {
        const container = document.getElementById('gameContainer');
        const sidePanel = document.getElementById('sidePanel');
        this.canvas.width  = container.offsetWidth - sidePanel.offsetWidth - 40;
        this.canvas.height = container.offsetHeight - 40;
        this.tower.x = this.canvas.width / 2;
        this.tower.y = this.canvas.height / 2;
      };
      resize();
      window.addEventListener('resize', resize);
    }
    
    gameLoop(timestamp) {
      if (this.isPaused || this.isGameOver) return;
      const delta = timestamp - this._lastFrame;
      this._lastFrame = timestamp;
      this.updateGame(delta);
      this.drawGame();
      this._raf = requestAnimationFrame(this.gameLoop.bind(this));
    }

    startNewGame() {
      if (this._raf) cancelAnimationFrame(this._raf);
      this.resetGameState();
      this.isGameOver = false; this.isPaused = false;
      this.updateUI();
      this._lastFrame = performance.now();
      this._raf = requestAnimationFrame(this.gameLoop.bind(this));
    }

    updateGame(delta) {
        if (!delta) return;
        if (!this.waveActive) {
            this.waveTimer += delta;
            if (this.waveTimer >= this.waveDelay) this.startWave();
        } else {
            if (this.enemiesSpawned < this.enemiesPerWave) {
                this.lastEnemySpawn += delta;
                if (this.lastEnemySpawn >= this.enemySpawnDelay) {
                    this.spawnEnemy(); this.enemiesSpawned++; this.lastEnemySpawn = 0;
                }
            }
            if (this.enemiesSpawned >= this.enemiesPerWave && this.enemies.length === 0) this.endWave();
        }

        for (let i = this.enemies.length - 1; i >= 0; i--) {
            const e = this.enemies[i];
            const dx = this.tower.x - e.x, dy = this.tower.y - e.y, dist = Math.hypot(dx, dy);
            if (dist > this.tower.radius + e.size) {
                e.x += (dx / dist) * e.speed * (delta / 16.67);
                e.y += (dy / dist) * e.speed * (delta / 16.67);
            } else {
                this.tower.hp -= e.damage; this.enemies.splice(i, 1);
                if (this.tower.hp <= 0) this.gameOver();
            }
        }

        this.units.forEach(u => {
            u.lastFire = (u.lastFire || 0) + delta;
            if (u.lastFire >= u.fireRate) {
                let target = this.enemies.find(e => Math.hypot(e.x - u.x, e.y - u.y) < u.range);
                if (target) { this.fireProjectile(u, target); u.lastFire = 0; }
            }
        });

        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const p = this.projectiles[i];
            p.x += p.vx * (delta / 16.67); p.y += p.vy * (delta / 16.67); p.life -= delta;
            if (p.life <= 0) { this.projectiles.splice(i, 1); continue; }
            for (let j = this.enemies.length - 1; j >= 0; j--) {
                const e = this.enemies[j];
                if (Math.hypot(p.x - e.x, p.y - e.y) < e.size + 3) {
                    this.damageEnemy(e, p.damage); this.projectiles.splice(i, 1); break;
                }
            }
        }
        this.updateUI();
    }

    drawGame() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = '#00ffcc'; this.ctx.beginPath();
        this.ctx.arc(this.tower.x, this.tower.y, this.tower.radius, 0, 2 * Math.PI); this.ctx.fill();
        this.units.forEach(u => { this.ctx.fillStyle = u.color; this.ctx.beginPath(); this.ctx.arc(u.x, u.y, u.size, 0, 2 * Math.PI); this.ctx.fill(); });
        this.enemies.forEach(e => { this.ctx.fillStyle = e.color; this.ctx.beginPath(); this.ctx.arc(e.x, e.y, e.size, 0, 2 * Math.PI); this.ctx.fill(); });
        this.projectiles.forEach(p => { this.ctx.fillStyle = p.color; this.ctx.beginPath(); this.ctx.arc(p.x, p.y, 3, 0, 2 * Math.PI); this.ctx.fill(); });
    }
    
    updateUI() {
        document.getElementById('waveCount').textContent = this.wave;
        document.getElementById('credits').textContent = this.credits;
        document.getElementById('score').textContent = this.score;
        document.getElementById('towerHp').textContent = `${Math.max(0, Math.ceil(this.tower.hp))}/${this.tower.maxHp}`;
        const timerEl = document.getElementById('waveTimer');
        if (!this.waveActive && !this.isGameOver) {
            timerEl.style.display = 'block';
            timerEl.textContent = `WAVE ${this.wave} IN: ${Math.ceil((this.waveDelay - this.waveTimer) / 1000)}s`;
        } else { timerEl.style.display = 'none'; }
        const unitSelection = document.getElementById('unitSelection');
        unitSelection.innerHTML = Object.entries(this.unitTypes).map(([key, u]) => `
          <div class="unit-card ${this.credits < u.cost ? 'disabled' : ''}" data-unit="${key}">
            <div class="unit-name">${u.name}</div><div class="unit-cost">COST: ${u.cost}c</div>
          </div>`).join('');
        unitSelection.querySelectorAll('.unit-card').forEach(c => c.addEventListener('click', () => this.selectUnit(c.dataset.unit)));
    }

    selectUnit(type) { if (this.credits >= this.unitTypes[type].cost) this.placingUnit = type; }
    
    placeUnit(x, y) {
        if (!this.placingUnit) return;
        const u = this.unitTypes[this.placingUnit];
        this.credits -= u.cost; this.units.push({ ...u, x, y });
        this.placingUnit = null; this.updateUI();
    }

    fireProjectile(unit, target) {
        const dx = target.x - unit.x, dy = target.y - unit.y, dist = Math.hypot(dx, dy) || 1;
        this.projectiles.push({ x: unit.x, y: unit.y, vx: (dx / dist) * unit.projectileSpeed, vy: (dy / dist) * unit.projectileSpeed, damage: unit.damage, color: unit.color, life: 2000 });
    }

    damageEnemy(enemy, damage) {
        enemy.hp -= damage;
        if (enemy.hp <= 0) {
            this.credits += enemy.reward; this.score += enemy.reward * 2;
            const idx = this.enemies.indexOf(enemy); if (idx > -1) this.enemies.splice(idx, 1);
        }
    }

    spawnEnemy() {
        const base = this.enemyTypes[Math.floor(Math.random() * this.enemyTypes.length)];
        let x, y; const edge = Math.random();
        if (edge < 0.25) { x = Math.random() * this.canvas.width; y = -base.size; }
        else if (edge < 0.5) { x = this.canvas.width + base.size; y = Math.random() * this.canvas.height; }
        else if (edge < 0.75) { x = Math.random() * this.canvas.width; y = this.canvas.height + base.size; }
        else { x = -base.size; y = Math.random() * this.canvas.height; }
        this.enemies.push({ ...base, x, y });
    }
    
    startWave() { this.waveActive = true; this.enemiesSpawned = 0; }
    endWave() { this.waveActive = false; this.waveTimer = 0; this.wave++; this.credits += 100; }
    
    togglePause() {
        this.isPaused = !this.isPaused;
        document.getElementById('pauseOverlay').style.display = this.isPaused ? 'flex' : 'none';
        if (!this.isPaused) { this._lastFrame = performance.now(); requestAnimationFrame(this.gameLoop.bind(this)); }
    }
    
    gameOver() {
        this.isGameOver = true;
        alert(`Game Over! Final Score: ${this.score}`);
        this.startNewGame();
    }
    
    saveGame() {
      const saveData = { wave: this.wave, credits: this.credits, score: this.score, towerHp: this.tower.hp, units: this.units };
      localStorage.setItem('orbitalDefenseSave', JSON.stringify(saveData));
      alert('Game Saved!');
    }

    loadGame() {
      const savedData = JSON.parse(localStorage.getItem('orbitalDefenseSave'));
      if (savedData) {
        this.wave = savedData.wave; this.credits = savedData.credits; this.score = savedData.score;
        this.tower.hp = savedData.towerHp; this.units = savedData.units;
        this.waveActive = false; this.waveTimer = 0; this.enemies = []; this.projectiles = [];
        this.updateUI();
        alert('Game Loaded!');
      } else { alert('No save data found!'); }
    }

    setupEventListeners() {
      document.getElementById('pauseBtn').addEventListener('click', () => this.togglePause());
      document.getElementById('saveBtn').addEventListener('click', () => this.saveGame());
      document.getElementById('loadBtn').addEventListener('click', () => this.loadGame());
      this.canvas.addEventListener('mousemove', e => { const rect = this.canvas.getBoundingClientRect(); this.mouseX = e.clientX - rect.left; this.mouseY = e.clientY - rect.top; });
      this.canvas.addEventListener('click', () => this.placeUnit(this.mouseX, this.mouseY));
    }
  }

  new OrbitalDefenseGame();
})();
</script>
</body>
</html>
