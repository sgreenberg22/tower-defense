<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>ORBITAL DEFENSE COMMAND</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #header {
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 2px solid #00ffcc;
            box-shadow: 0 2px 20px rgba(0, 255, 204, 0.3);
        }
        .stat-display { display: flex; gap: 30px; font-size: 18px; font-weight: bold; }
        .stat-item { color: #00ffcc; text-shadow: 0 0 10px rgba(0, 255, 204, 0.5); }
        .stat-label { color: #8899aa; margin-right: 5px; }
        #gameContainer { flex: 1; display: flex; position: relative; }
        #canvas {
            background: radial-gradient(ellipse at center, #1a2332 0%, #0a0e1a 100%);
            border: 2px solid #00ffcc; box-shadow: 0 0 50px rgba(0, 255, 204, 0.2); margin: 20px;
        }
        #sidePanel {
            width: 350px; background: rgba(0, 0, 0, 0.9); padding: 20px; overflow-y: auto;
            border-left: 2px solid #00ffcc;
        }
        .panel-section { margin-bottom: 25px; padding: 15px; background: rgba(26, 31, 58, 0.5);
            border-radius: 8px; border: 1px solid rgba(0, 255, 204, 0.3);}
        .section-title {
            font-size: 20px; color: #00ffcc; margin-bottom: 15px; text-transform: uppercase; letter-spacing: 2px;
            text-shadow: 0 0 15px rgba(0, 255, 204, 0.7);
        }
        .unit-card {
            background: rgba(0, 255, 204, 0.1);
            border: 1px solid #00ffcc;
            padding: 12px; margin-bottom: 12px; border-radius: 5px; cursor: pointer;
            transition: all 0.3s ease; position: relative; overflow: hidden;
        }
        .unit-card::before {
            content: ''; position: absolute; inset: -2px;
            background: linear-gradient(45deg, #00ffcc, #0099ff, #00ffcc);
            border-radius: 5px; opacity: 0; z-index: -1; transition: opacity 0.3s ease;
        }
        .unit-card:hover::before { opacity: 0.5; }
        .unit-card:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0, 255, 204, 0.4); }
        .unit-card.selected { background: rgba(0, 255, 204, 0.3); border-color: #fff; }
        .unit-card.disabled { opacity: 0.5; cursor: not-allowed; }
        .unit-name { font-size: 16px; font-weight: bold; color: #fff; margin-bottom: 5px; }
        .unit-stats { font-size: 12px; color: #8899aa; line-height: 1.5; }
        .unit-cost { font-size: 14px; color: #ffaa00; font-weight: bold; margin-top: 5px; }
        .upgrade-button {
            background: linear-gradient(135deg, #00ffcc, #0099ff);
            border: none; color: #000; padding: 8px 16px; border-radius: 4px; cursor: pointer;
            font-weight: bold; margin-top: 8px; transition: all 0.3s ease;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .upgrade-button:hover:not(:disabled) { transform: scale(1.05); box-shadow: 0 5px 20px rgba(0, 255, 204, 0.6); }
        .upgrade-button:disabled { opacity: 0.5; cursor: not-allowed; background: #555; }
        #menuOverlay {
            position: fixed; inset: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex; justify-content: center; align-items: center; z-index: 1000;
        }
        .menu-container {
            background: linear-gradient(135deg, #1a2332 0%, #0a0e1a 100%);
            border: 2px solid #00ffcc; border-radius: 15px; padding: 40px; text-align: center;
            box-shadow: 0 0 50px rgba(0, 255, 204, 0.5); max-width: 500px;
        }
        .game-title {
            font-size: 48px; color: #00ffcc; margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(0, 255, 204, 0.8); letter-spacing: 3px; animation: glow 2s ease-in-out infinite alternate;
        }
        @keyframes glow { from { text-shadow: 0 0 30px rgba(0, 255, 204, 0.8);} to { text-shadow: 0 0 40px rgba(0, 255, 204, 1), 0 0 50px rgba(0, 153, 255, 0.8);} }
        .game-subtitle { font-size: 18px; color: #8899aa; margin-bottom: 30px; letter-spacing: 2px; }
        .menu-button {
            background: linear-gradient(135deg, #00ffcc, #0099ff); border: none; color: #000; padding: 15px 40px; margin: 10px;
            border-radius: 8px; cursor: pointer; font-size: 18px; font-weight: bold; text-transform: uppercase;
            letter-spacing: 2px; transition: all 0.3s ease; display: block; width: 100%;
        }
        .menu-button:hover { transform: scale(1.05); box-shadow: 0 10px 30px rgba(0, 255, 204, 0.6); }
        .menu-button.secondary { background: transparent; border: 2px solid #00ffcc; color: #00ffcc; }
        .high-scores { margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(0, 255, 204, 0.3); }
        .high-score-item { display: flex; justify-content: space-between; padding: 8px; margin: 5px 0; background: rgba(0, 255, 204, 0.1); border-radius: 4px; }
        #pauseMenu { display: none; }
        .warning-flash { animation: warningFlash 0.5s ease-in-out infinite alternate; }
        @keyframes warningFlash { from { background: rgba(255, 0, 0, 0.3);} to { background: rgba(255, 0, 0, 0.6);} }
        .particle { position: absolute; pointer-events: none; border-radius: 50%; }
        #waveTimer {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            font-size: 24px; color: #ffaa00; font-weight: bold; text-shadow: 0 0 20px rgba(255, 170, 0, 0.8);
            background: rgba(0, 0, 0, 0.8); padding: 10px 20px; border-radius: 8px; border: 2px solid #ffaa00;
        }
        .speed-control {
            position: absolute; bottom: 30px; left: 30px; display: flex; gap: 10px;
            background: rgba(0, 0, 0, 0.8); padding: 10px; border-radius: 8px; border: 1px solid #00ffcc;
        }
        .speed-button { background: rgba(0, 255, 204, 0.2); border: 1px solid #00ffcc; color: #00ffcc; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.2s ease; }
        .speed-button:hover { background: rgba(0, 255, 204, 0.4); }
        .speed-button.active { background: #00ffcc; color: #000; }
        .notification {
            position: fixed; top: 20px; right: 20px; background: rgba(0, 0, 0, 0.9); color: #00ffcc; padding: 15px 25px;
            border-radius: 8px; border: 2px solid #00ffcc; z-index: 2000; animation: slideIn 0.3s ease-out;
            max-width: 360px; text-align: left;
        }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0;} to { transform: translateX(0); opacity: 1;} }
        .boss-warning {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9); color: #fff; padding: 30px; border-radius: 15px;
            font-size: 32px; font-weight: bold; text-align: center; z-index: 2000; animation: bossWarning 3s ease-in-out;
        }
        @keyframes bossWarning { 0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5);} 50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1);} }
        .achievement {
            position: fixed; bottom: 20px; right: 20px; background: linear-gradient(135deg, #ffaa00, #ff6600);
            color: #000; padding: 15px 25px; border-radius: 8px; font-weight: bold; z-index: 2000; animation: achievementPop 3s ease-out;
        }
        @keyframes achievementPop {
            0% { transform: translateY(100px); opacity: 0; }
            20% { transform: translateY(0); opacity: 1; }
            80% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(100px); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="header">
        <div class="stat-display">
            <div class="stat-item"><span class="stat-label">WAVE:</span><span id="waveCount">1</span></div>
            <div class="stat-item"><span class="stat-label">CREDITS:</span><span id="credits">1000</span></div>
            <div class="stat-item"><span class="stat-label">SCORE:</span><span id="score">0</span></div>
            <div class="stat-item"><span class="stat-label">TOWER HP:</span><span id="towerHp">100/100</span></div>
        </div>
        <div>
            <button class="upgrade-button" onclick="togglePause()">PAUSE</button>
            <button class="upgrade-button" onclick="saveGame()">SAVE</button>
            <button class="upgrade-button" onclick="returnToMenu()">MENU</button>
        </div>
    </div>

    <div id="gameContainer">
        <canvas id="canvas"></canvas>
        <div id="waveTimer"></div>
        <div class="speed-control">
            <button class="speed-button active" onclick="setSpeed(1)">1x</button>
            <button class="speed-button" onclick="setSpeed(2)">2x</button>
            <button class="speed-button" onclick="setSpeed(3)">3x</button>
        </div>
        <div id="sidePanel">
            <div class="panel-section">
                <div class="section-title">Deploy Units</div>
                <div id="unitSelection"></div>
            </div>
            <div class="panel-section">
                <div class="section-title">Upgrades</div>
                <div id="upgradesSection"></div>
            </div>
            <div class="panel-section">
                <div class="section-title">Wave Info</div>
                <div id="waveInfo"></div>
            </div>
            <div class="panel-section">
                <div class="section-title">Achievements</div>
                <div id="achievementsSection"></div>
            </div>
        </div>
    </div>

    <div id="menuOverlay">
        <div class="menu-container" id="mainMenu">
            <h1 class="game-title">ORBITAL DEFENSE</h1>
            <p class="game-subtitle">COMMAND CENTER ALPHA-9</p>
            <button class="menu-button" onclick="startNewGame()">NEW MISSION</button>
            <button class="menu-button secondary" onclick="loadGame()">CONTINUE MISSION</button>
            <button class="menu-button secondary" onclick="showDailyChallenge()">DAILY CHALLENGE</button>
            <div class="high-scores">
                <div class="section-title">TOP COMMANDERS</div>
                <div id="highScoresList"></div>
            </div>
        </div>
        <div class="menu-container" id="pauseMenu" style="display: none;">
            <h2 class="game-title">MISSION PAUSED</h2>
            <button class="menu-button" onclick="togglePause()">RESUME</button>
            <button class="menu-button secondary" onclick="saveGame()">SAVE PROGRESS</button>
            <button class="menu-button secondary" onclick="returnToMenu()">ABANDON MISSION</button>
        </div>
        <div class="menu-container" id="gameOverMenu" style="display: none;">
            <h2 class="game-title">MISSION FAILED</h2>
            <p id="finalScore" style="font-size: 24px; color: #ffaa00; margin: 20px 0;"></p>
            <button class="menu-button" onclick="startNewGame()">NEW MISSION</button>
            <button class="menu-button secondary" onclick="returnToMenu()">MAIN MENU</button>
        </div>
        <!-- Daily Challenge modal (created dynamically if needed) -->
    </div>

    <script>
    (function () {
        class ObjectPool {
            constructor(createFn, resetFn, initialSize = 50) {
                this.createFn = createFn;
                this.resetFn = resetFn;
                this.pool = [];
                this.active = [];
                for (let i = 0; i < initialSize; i++) this.pool.push(this.createFn());
            }
            get() {
                let obj = this.pool.pop();
                if (!obj) obj = this.createFn();
                this.active.push(obj);
                return obj;
            }
            release(obj) {
                const idx = this.active.indexOf(obj);
                if (idx > -1) {
                    this.active.splice(idx, 1);
                    this.resetFn(obj);
                    this.pool.push(obj);
                }
            }
            releaseAll() { while (this.active.length > 0) this.release(this.active[0]); }
        }

        class OrbitalDefenseGame {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas();

                this.gameSpeed = 1;
                this.isPaused = false;
                this.isGameOver = false;
                this.selectedUnit = null;
                this.placingUnit = null;

                this._raf = null;
                this._lastFrame = 0;

                // Object pools
                this.projectilePool = new ObjectPool(
                    () => ({ x:0, y:0, vx:0, vy:0, damage:0, color:'#fff', size:3, life:120, explosive:false, piercing:false, chainLightning:false }),
                    (o) => { o.life = 120; o.explosive = o.piercing = o.chainLightning = false; }
                );
                this.particlePool = new ObjectPool(
                    () => ({ x:0, y:0, vx:0, vy:0, life:30, maxLife:30, color:'#fff', size:2 }),
                    (o) => { o.life = o.maxLife; }
                );

                // Game state
                this.wave = 1;
                this.credits = 1000;
                this.score = 0;
                this.tower = { x: 0, y: 0, maxHp: 100, hp: 100, radius: 40 };

                // Collections
                this.units = [];
                this.enemies = [];
                this.projectiles = [];
                this.particles = [];
                this.upgrades = { damageBoost: 0, rangeBoost: 0, fireRateBoost: 0, creditBonus: 0 };

                // Achievements
                this.achievements = {
                    firstKill:   { unlocked: false, name: "First Blood",     desc: "Destroy your first enemy" },
                    wave10:      { unlocked: false, name: "Veteran",         desc: "Survive 10 waves" },
                    wave25:      { unlocked: false, name: "Elite",           desc: "Survive 25 waves" },
                    score10k:    { unlocked: false, name: "High Scorer",     desc: "Reach 10,000 points" },
                    firstBoss:   { unlocked: false, name: "Boss Slayer",     desc: "Defeat your first boss" },
                    perfectWave: { unlocked: false, name: "Perfect Defense", desc: "Complete a wave without taking damage" }
                };

                // Waves
                this.waveTimer = 0;
                this.waveDelay = 15000;   // ms
                this.enemiesPerWave = 8;
                this.enemySpawnDelay = 1000; // ms
                this.lastEnemySpawn = 0;
                this.enemiesSpawned = 0;
                this.waveActive = false;
                this.waveDamage = 0;
                this.bossWave = false;

                // Daily challenge
                this.dailyChallenge = this.generateDailyChallenge();

                // Units
                this.unitTypes = {
                    turret: { name:"PLASMA TURRET", cost:100, damage:15, range:120, fireRate:800, hp:50, color:'#00ffcc', size:20, projectileSpeed:8, unlocked:true },
                    laser:  { name:"LASER CANNON",  cost:200, damage:8,  range:180, fireRate:150, hp:40, color:'#ff00ff', size:25, projectileSpeed:20, unlocked:false, unlockWave:3 },
                    missile:{ name:"MISSILE SILO",  cost:350, damage:80, range:200, fireRate:2500, hp:60, color:'#ffaa00', size:30, projectileSpeed:4,  explosive:true, unlocked:false, unlockWave:5 },
                    railgun:{ name:"RAILGUN",       cost:500, damage:150,range:300, fireRate:3000, hp:80, color:'#00aaff', size:35, projectileSpeed:25, piercing:true, unlocked:false, unlockWave:8 },
                    tesla:  { name:"TESLA COIL",    cost:600, damage:25, range:100, fireRate:400,  hp:100,color:'#aaffff', size:28, projectileSpeed:0,  chainLightning:true, unlocked:false, unlockWave:12 }
                };

                // Enemies
                this.enemyTypes = [
                    { name:"Scout",  hp:30,  speed:1.5, damage:8,  reward:25,  color:'#ff6666', size:12 },
                    { name:"Fighter",hp:60,  speed:1.2, damage:15, reward:40,  color:'#ff9966', size:16 },
                    { name:"Heavy",  hp:120, speed:0.8, damage:25, reward:70,  color:'#ff66ff', size:22 },
                    { name:"Elite",  hp:200, speed:1.0, damage:40, reward:120, color:'#ffff66', size:25 }
                ];

                this.mouseX = 0;
                this.mouseY = 0;

                this.setupEventListeners();
                this.loadHighScores();
                this.loadAchievements();
                this.updateUI();
            }

            setupCanvas() {
                const resize = () => {
                    const container = document.getElementById('gameContainer');
                    const sidePanel = document.getElementById('sidePanel');
                    const margins = 40; // canvas margin (20 * 2)
                    this.canvas.width  = Math.max(200, container.offsetWidth - sidePanel.offsetWidth - margins);
                    this.canvas.height = Math.max(200, container.offsetHeight - margins);
                    this.tower.x = this.canvas.width / 2;
                    this.tower.y = this.canvas.height / 2;
                };
                resize();
                window.addEventListener('resize', resize);
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouseX = e.clientX - rect.left;
                    this.mouseY = e.clientY - rect.top;
                });
                this.canvas.addEventListener('click', () => {
                    if (this.placingUnit) this.placeUnit(this.mouseX, this.mouseY);
                });
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    this.cancelPlacement();
                });
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') this.cancelPlacement();
                    if (e.key === ' ') { e.preventDefault(); this.togglePause(); }
                });
            }

            generateDailyChallenge() {
                const today = new Date().toDateString();
                const challenges = [
                    { name: "Speed Run", desc: "Survive 15 waves in under 10 minutes", type: "time" },
                    { name: "Minimalist", desc: "Beat wave 10 with 5 or fewer units", type: "units" },
                    { name: "Economy", desc: "Reach 5000 credits", type: "credits" },
                    { name: "Pacifist", desc: "Beat 5 waves without killing any scouts", type: "pacifist" }
                ];
                const seed = today.split('').reduce((a, b) => a + b.charCodeAt(0), 0);
                return challenges[seed % challenges.length];
            }

            startNewGame() {
                this.wave = 1;
                this.credits = 1000;
                this.score = 0;
                this.tower.hp = this.tower.maxHp;

                this.units = [];
                this.enemies = [];
                this.projectilePool.releaseAll();
                this.particlePool.releaseAll();
                this.projectiles = [];
                this.particles = [];

                this.upgrades = { damageBoost:0, rangeBoost:0, fireRateBoost:0, creditBonus:0 };

                this.waveTimer = 0;
                this.enemiesSpawned = 0;
                this.waveActive = false;
                this.isGameOver = false;
                this.isPaused = false;
                this.waveDamage = 0;
                this.bossWave = false;

                document.getElementById('menuOverlay').style.display = 'none';
                this.setSpeed(this.gameSpeed); // keep current button highlight
                this.updateUI();
                this.gameLoop(); // ensures single loop
            }

            saveGame() {
                const saveData = {
                    wave: this.wave,
                    credits: this.credits,
                    score: this.score,
                    tower: { ...this.tower }, // keep center
                    units: this.units.map(u => ({ type: u.type, x: u.x, y: u.y, hp: u.hp })),
                    upgrades: { ...this.upgrades },
                    timestamp: Date.now()
                };
                localStorage.setItem('orbitalDefenseSave', JSON.stringify(saveData));
                this.showNotification('Game Saved!');
            }

            loadGame() {
                const saveData = localStorage.getItem('orbitalDefenseSave');
                if (!saveData) { this.showNotification('No save found!'); return; }

                const data = JSON.parse(saveData);
                this.wave = data.wave;
                this.credits = data.credits;
                this.score = data.score;
                this.tower = { ...this.tower, hp: data.tower.hp, maxHp: data.tower.maxHp }; // keep centered position
                this.upgrades = data.upgrades || { damageBoost:0, rangeBoost:0, fireRateBoost:0, creditBonus:0 };

                this.units = (data.units || []).map(u => {
                    const unitType = this.unitTypes[u.type];
                    return { ...unitType, type: u.type, x: u.x, y: u.y, hp: u.hp, maxHp: unitType.hp, lastFire: 0 };
                });

                this.enemies = [];
                this.projectilePool.releaseAll();
                this.particlePool.releaseAll();
                this.projectiles = [];
                this.particles = [];
                this.waveTimer = 0;
                this.enemiesSpawned = 0;
                this.waveActive = false;
                this.isGameOver = false;
                this.isPaused = false;
                this.waveDamage = 0;
                this.bossWave = false;

                document.getElementById('menuOverlay').style.display = 'none';
                this.updateUI();
                this.gameLoop();
            }

            togglePause() {
                if (this.isGameOver) return;
                this.isPaused = !this.isPaused;
                const pauseMenu = document.getElementById('pauseMenu');
                const mainMenu = document.getElementById('mainMenu');
                if (this.isPaused) {
                    document.getElementById('menuOverlay').style.display = 'flex';
                    pauseMenu.style.display = 'block';
                    mainMenu.style.display = 'none';
                } else {
                    document.getElementById('menuOverlay').style.display = 'none';
                }
            }

            returnToMenu() {
                this.isPaused = true;
                this.isGameOver = true;
                const pauseMenu = document.getElementById('pauseMenu');
                const mainMenu = document.getElementById('mainMenu');
                const gameOverMenu = document.getElementById('gameOverMenu');
                document.getElementById('menuOverlay').style.display = 'flex';
                pauseMenu.style.display = 'none';
                gameOverMenu.style.display = 'none';
                mainMenu.style.display = 'block';
                this.loadHighScores();
            }

            setSpeed(speed) {
                this.gameSpeed = speed;
                const buttons = document.querySelectorAll('.speed-button');
                buttons.forEach(btn => {
                    const val = parseInt(btn.textContent, 10);
                    if (val === speed) btn.classList.add('active'); else btn.classList.remove('active');
                });
            }

            selectUnit(type) {
                const unitType = this.unitTypes[type];
                if (!unitType.unlocked) { this.showNotification(`Unlocks at wave ${unitType.unlockWave}`); return; }
                if (this.credits < unitType.cost) { this.showNotification('Insufficient credits!'); return; }
                this.placingUnit = type;
                document.querySelectorAll('.unit-card').forEach(c => c.classList.remove('selected'));
                const card = document.querySelector(`[data-unit="${type}"]`);
                if (card) card.classList.add('selected');
            }

            cancelPlacement() {
                this.placingUnit = null;
                document.querySelectorAll('.unit-card').forEach(c => c.classList.remove('selected'));
            }

            placeUnit(x, y) {
                if (!this.placingUnit) return;
                const unitType = this.unitTypes[this.placingUnit];

                // Too close to tower?
                const distToTower = Math.hypot(x - this.tower.x, y - this.tower.y);
                if (distToTower < this.tower.radius + unitType.size + 20) { this.showNotification('Too close to tower!'); return; }

                // Too close to other units?
                for (let unit of this.units) {
                    const d = Math.hypot(x - unit.x, y - unit.y);
                    if (d < unit.size + unitType.size + 10) { this.showNotification('Too close to another unit!'); return; }
                }

                // Create unit
                this.credits -= unitType.cost;
                this.units.push({
                    ...unitType,
                    type: this.placingUnit,
                    x, y,
                    hp: unitType.hp, maxHp: unitType.hp, lastFire: 0
                });

                this.cancelPlacement();
                this.updateUI();
                this.createParticles(x, y, unitType.color, 10);
            }

            spawnEnemy() {
                const waveMultiplier = Math.pow(1.12, this.wave - 1);
                const idx = Math.min(Math.floor(Math.random() * (1 + this.wave / 4)), this.enemyTypes.length - 1);
                const base = this.enemyTypes[idx];

                // Spawn from random edge
                const edge = Math.random() * 4;
                let x, y;
                if (edge < 1) { x = Math.random() * this.canvas.width; y = 0; }
                else if (edge < 2) { x = this.canvas.width; y = Math.random() * this.canvas.height; }
                else if (edge < 3) { x = Math.random() * this.canvas.width; y = this.canvas.height; }
                else { x = 0; y = Math.random() * this.canvas.height; }

                this.enemies.push({
                    x, y,
                    hp: Math.floor(base.hp * waveMultiplier),
                    maxHp: Math.floor(base.hp * waveMultiplier),
                    speed: base.speed * (1 + this.wave * 0.015),
                    damage: Math.floor(base.damage * waveMultiplier),
                    reward: Math.floor(base.reward * (1 + this.upgrades.creditBonus * 0.1)),
                    color: base.color, size: base.size, type: base.name
                });
            }

            spawnBoss() {
                const bossMultiplier = Math.pow(1.3, Math.floor(this.wave / 10));
                const x = this.canvas.width / 2, y = 0;
                this.enemies.push({
                    x, y,
                    hp: Math.floor(1000 * bossMultiplier),
                    maxHp: Math.floor(1000 * bossMultiplier),
                    speed: 0.5,
                    damage: Math.floor(100 * bossMultiplier),
                    reward: Math.floor(500 * bossMultiplier),
                    color: '#ff0000', size: 50, type: 'Boss', isBoss: true
                });
                this.showBossWarning();
            }

            showBossWarning() {
                const warning = document.createElement('div');
                warning.className = 'boss-warning';
                warning.textContent = 'BOSS INCOMING!';
                document.body.appendChild(warning);
                setTimeout(() => document.body.removeChild(warning), 3000);
            }

            startWave() {
                this.waveActive = true;
                this.enemiesSpawned = 0;
                this.lastEnemySpawn = 0;
                this.waveDamage = 0;

                // Unlock units
                Object.keys(this.unitTypes).forEach(type => {
                    const unit = this.unitTypes[type];
                    if (unit.unlockWave && this.wave >= unit.unlockWave && !unit.unlocked) {
                        unit.unlocked = true;
                        this.showNotification(`${unit.name} unlocked!`);
                    }
                });

                // Boss every 10th wave
                this.bossWave = (this.wave % 10 === 0);
                if (this.bossWave) {
                    this.enemiesPerWave = 1;
                    this.spawnBoss();            // spawn immediately to prevent premature wave end
                    this.enemiesSpawned = 1;     // count it
                } else {
                    this.enemiesPerWave = Math.floor(8 + this.wave * 1.5);
                }

                this.updateUI();
            }

            endWave() {
                this.waveActive = false;
                this.waveTimer = 0;
                this.wave++;

                const bonus = Math.floor(50 + this.wave * 10);
                this.credits += bonus;
                this.score += bonus * 2;

                if (this.waveDamage === 0 && this.wave > 1) this.unlockAchievement('perfectWave');
                if (this.wave === 10) this.unlockAchievement('wave10');
                if (this.wave === 25) this.unlockAchievement('wave25');

                this.showNotification(`Wave ${this.wave - 1} Complete! +${bonus} credits`);
                this.updateUI();
            }

            updateGame(delta) {
                if (this.isPaused || this.isGameOver) return;
                const dt = delta * this.gameSpeed;

                // Wave control
                if (!this.waveActive) {
                    this.waveTimer += dt;
                    if (this.waveTimer >= this.waveDelay) this.startWave();
                } else {
                    if (!this.bossWave && this.enemiesSpawned < this.enemiesPerWave) {
                        this.lastEnemySpawn += dt;
                        if (this.lastEnemySpawn >= this.enemySpawnDelay) {
                            this.spawnEnemy();
                            this.enemiesSpawned++;
                            this.lastEnemySpawn = 0;
                        }
                    }
                    if (this.enemiesSpawned >= this.enemiesPerWave && this.enemies.length === 0) {
                        this.endWave();
                    }
                }

                // Enemies move
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    const dx = this.tower.x - enemy.x;
                    const dy = this.tower.y - enemy.y;
                    const dist = Math.hypot(dx, dy);

                    if (dist > this.tower.radius + enemy.size) {
                        enemy.x += (dx / dist) * enemy.speed * (dt / 16);
                        enemy.y += (dy / dist) * enemy.speed * (dt / 16);
                    } else {
                        // Hit tower once and remove enemy
                        this.tower.hp -= enemy.damage;
                        this.waveDamage += enemy.damage;
                        this.createParticles(enemy.x, enemy.y, '#ff0000', 20);
                        this.enemies.splice(i, 1);

                        if (this.tower.hp <= 0) this.gameOver();
                    }
                }

                // Units fire
                for (let unit of this.units) {
                    unit.lastFire += dt;
                    const effectiveFireRate = unit.fireRate * (1 - this.upgrades.fireRateBoost * 0.1);
                    const effectiveRange = unit.range * (1 + this.upgrades.rangeBoost * 0.1);

                    if (unit.lastFire >= effectiveFireRate) {
                        let target = null;
                        let minDist = effectiveRange;
                        for (let enemy of this.enemies) {
                            const d = Math.hypot(enemy.x - unit.x, enemy.y - unit.y);
                            if (d < minDist) { target = enemy; minDist = d; }
                        }
                        if (target) { this.fireProjectile(unit, target); unit.lastFire = 0; }
                    }
                }

                // Projectiles
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const p = this.projectiles[i];
                    p.x += p.vx * (dt / 16);
                    p.y += p.vy * (dt / 16);
                    p.life--;
                    if (p.life <= 0) { this.projectilePool.release(p); this.projectiles.splice(i, 1); continue; }

                    // Collisions
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const e = this.enemies[j];
                        const d = Math.hypot(p.x - e.x, p.y - e.y);
                        if (d < e.size + p.size) {
                            if (p.explosive) {
                                this.handleExplosion(p.x, p.y, p.damage);
                                this.projectilePool.release(p);
                                this.projectiles.splice(i, 1);
                            } else if (p.piercing) {
                                this.damageEnemy(e, p.damage); // keep traveling
                            } else if (p.chainLightning) {
                                this.handleChainLightning(e, p.damage, 3);
                                this.projectilePool.release(p);
                                this.projectiles.splice(i, 1);
                            } else {
                                this.damageEnemy(e, p.damage);
                                this.projectilePool.release(p);
                                this.projectiles.splice(i, 1);
                            }
                            break;
                        }
                    }
                }

                // Particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const part = this.particles[i];
                    part.x += part.vx * (dt / 16);
                    part.y += part.vy * (dt / 16);
                    part.life--;
                    if (part.life <= 0) { this.particlePool.release(part); this.particles.splice(i, 1); }
                }

                this.updateUI();
            }

            fireProjectile(unit, target) {
                const dx = target.x - unit.x;
                const dy = target.y - unit.y;
                const dist = Math.hypot(dx, dy);

                const proj = this.projectilePool.get();
                proj.x = unit.x; proj.y = unit.y;
                proj.vx = (dx / dist) * (unit.projectileSpeed || 16);
                proj.vy = (dy / dist) * (unit.projectileSpeed || 16);
                proj.damage = Math.round(unit.damage * (1 + this.upgrades.damageBoost * 0.1));
                proj.color = unit.color;
                proj.size = unit.name.includes('MISSILE') ? 6 : 3;
                proj.explosive = !!unit.explosive;
                proj.piercing = !!unit.piercing;
                proj.chainLightning = !!unit.chainLightning;
                proj.life = 120;

                this.projectiles.push(proj);
            }

            damageEnemy(enemy, damage) {
                enemy.hp -= damage;
                this.createParticles(enemy.x, enemy.y, enemy.color, 5);
                if (enemy.hp <= 0) {
                    this.credits += enemy.reward;
                    this.score += enemy.reward * 2;
                    if (this.score >= 10000) this.unlockAchievement('score10k');
                    if (enemy.isBoss) this.unlockAchievement('firstBoss');
                    if (!this.achievements.firstKill.unlocked) this.unlockAchievement('firstKill');
                    this.createParticles(enemy.x, enemy.y, '#ffaa00', 15);
                    const idx = this.enemies.indexOf(enemy);
                    if (idx > -1) this.enemies.splice(idx, 1);
                }
            }

            handleExplosion(x, y, damage) {
                this.createParticles(x, y, '#ffaa00', 25);
                for (let enemy of this.enemies) {
                    const d = Math.hypot(enemy.x - x, enemy.y - y);
                    if (d < 80) {
                        const explosionDamage = Math.max(1, Math.round(damage * (1 - d / 80)));
                        this.damageEnemy(enemy, explosionDamage);
                    }
                }
            }

            handleChainLightning(startEnemy, damage, chains) {
                this.damageEnemy(startEnemy, damage);
                if (chains <= 0) return;

                let closest = null;
                let minDist = 150;
                for (let enemy of this.enemies) {
                    if (enemy !== startEnemy) {
                        const d = Math.hypot(enemy.x - startEnemy.x, enemy.y - startEnemy.y);
                        if (d < minDist) { closest = enemy; minDist = d; }
                    }
                }
                if (closest) setTimeout(() => this.handleChainLightning(closest, Math.round(damage * 0.7), chains - 1), 100);
            }

            createParticles(x, y, color, count) {
                for (let i = 0; i < count; i++) {
                    const p = this.particlePool.get();
                    p.x = x; p.y = y;
                    p.vx = (Math.random() - 0.5) * 8;
                    p.vy = (Math.random() - 0.5) * 8;
                    p.color = color;
                    p.size = Math.random() * 4 + 1;
                    p.life = Math.floor(Math.random() * 30 + 20);
                    p.maxLife = p.life;
                    this.particles.push(p);
                }
            }

            gameOver() {
                this.isGameOver = true;
                this.isPaused = true;
                this.saveHighScore(this.score);
                const gameOverMenu = document.getElementById('gameOverMenu');
                const mainMenu = document.getElementById('mainMenu');
                document.getElementById('menuOverlay').style.display = 'flex';
                document.getElementById('finalScore').textContent = `Final Score: ${this.score.toLocaleString()}`;
                gameOverMenu.style.display = 'block';
                mainMenu.style.display = 'none';
            }

            render() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Starfield
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                for (let i = 0; i < 100; i++) {
                    const x = (i * 137.5) % this.canvas.width;
                    const y = (i * 317.3) % this.canvas.height;
                    ctx.fillRect(x, y, 1, 1);
                }

                // Tower
                ctx.fillStyle = this.tower.hp > 50 ? '#00ffcc' : '#ff6666';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.tower.x, this.tower.y, this.tower.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Tower HP bar
                const hpPct = Math.max(0, this.tower.hp) / this.tower.maxHp;
                ctx.fillStyle = '#333';
                ctx.fillRect(this.tower.x - 40, this.tower.y - 60, 80, 8);
                ctx.fillStyle = hpPct > 0.5 ? '#00ff00' : hpPct > 0.25 ? '#ffaa00' : '#ff0000';
                ctx.fillRect(this.tower.x - 40, this.tower.y - 60, 80 * hpPct, 8);

                // Units
                for (let unit of this.units) {
                    ctx.fillStyle = unit.color;
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;

                    if (unit.name.includes('TURRET')) {
                        ctx.fillRect(unit.x - unit.size/2, unit.y - unit.size/2, unit.size, unit.size);
                        ctx.strokeRect(unit.x - unit.size/2, unit.y - unit.size/2, unit.size, unit.size);
                    } else {
                        ctx.beginPath();
                        ctx.arc(unit.x, unit.y, unit.size/2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }

                    const pct = unit.hp / unit.maxHp;
                    if (pct < 1) {
                        ctx.fillStyle = '#333';
                        ctx.fillRect(unit.x - 15, unit.y - unit.size/2 - 8, 30, 4);
                        ctx.fillStyle = pct > 0.5 ? '#00ff00' : pct > 0.25 ? '#ffaa00' : '#ff0000';
                        ctx.fillRect(unit.x - 15, unit.y - unit.size/2 - 8, 30 * pct, 4);
                    }

                    // Show range when placing same type or when selected
                    if (this.placingUnit === unit.type || unit === this.selectedUnit) {
                        ctx.strokeStyle = 'rgba(0, 255, 204, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(unit.x, unit.y, unit.range * (1 + this.upgrades.rangeBoost * 0.1), 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                // Enemies
                for (let enemy of this.enemies) {
                    ctx.fillStyle = enemy.color;
                    ctx.strokeStyle = enemy.isBoss ? '#ffffff' : '#333';
                    ctx.lineWidth = enemy.isBoss ? 3 : 1;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // HP bar
                    const epct = enemy.hp / enemy.maxHp;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(enemy.x - enemy.size, enemy.y - enemy.size - 8, enemy.size * 2, 4);
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(enemy.x - enemy.size, enemy.y - enemy.size - 8, enemy.size * 2 * epct, 4);

                    if (enemy.isBoss) {
                        ctx.fillStyle = '#ffaa00';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('BOSS', enemy.x, enemy.y - enemy.size - 15);
                    }
                }

                // Projectiles
                for (let proj of this.projectiles) {
                    ctx.fillStyle = proj.color;
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }

                // Particles with alpha fade
                for (let particle of this.particles) {
                    const alpha = particle.life / particle.maxLife;
                    ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                // Placement preview
                if (this.placingUnit) {
                    const unitType = this.unitTypes[this.placingUnit];
                    ctx.fillStyle = 'rgba(0, 255, 204, 0.5)';
                    ctx.strokeStyle = '#00ffcc';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.mouseX, this.mouseY, unitType.size/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    ctx.strokeStyle = 'rgba(0, 255, 204, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(this.mouseX, this.mouseY, unitType.range, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            updateUI() {
                document.getElementById('waveCount').textContent = this.wave;
                document.getElementById('credits').textContent = this.credits.toLocaleString();
                document.getElementById('score').textContent = this.score.toLocaleString();
                document.getElementById('towerHp').textContent = `${Math.max(0, Math.round(this.tower.hp))}/${this.tower.maxHp}`;

                const timer = document.getElementById('waveTimer');
                if (!this.waveActive && !this.isGameOver) {
                    const remaining = Math.max(0, Math.ceil((this.waveDelay - this.waveTimer) / 1000));
                    timer.textContent = `Next wave in: ${remaining}s`;
                    timer.style.display = 'block';
                } else {
                    timer.style.display = 'none';
                }

                this.updateUnitSelection();
                this.updateUpgrades();
                this.updateWaveInfo();
                this.updateAchievements();
            }

            updateUnitSelection() {
                const container = document.getElementById('unitSelection');
                container.innerHTML = '';
                Object.keys(this.unitTypes).forEach(type => {
                    const unit = this.unitTypes[type];
                    const canAfford = this.credits >= unit.cost;

                    const card = document.createElement('div');
                    card.className = `unit-card ${(!unit.unlocked || !canAfford) ? 'disabled' : ''}`;
                    card.setAttribute('data-unit', type);
                    card.onclick = () => this.selectUnit(type);

                    card.innerHTML = `
                        <div class="unit-name">${unit.name}</div>
                        <div class="unit-stats">
                            Damage: ${unit.damage} | Range: ${unit.range}<br>
                            Fire Rate: ${(1000/unit.fireRate).toFixed(1)}/s | HP: ${unit.hp}
                        </div>
                        <div class="unit-cost">Cost: ${unit.cost} credits</div>
                        ${!unit.unlocked ? `<div style="color:#ffaa00; font-size:12px;">Unlocks Wave ${unit.unlockWave}</div>` : ''}
                    `;
                    container.appendChild(card);
                });
            }

            updateUpgrades() {
                const container = document.getElementById('upgradesSection');
                const defs = [
                    { key: 'damageBoost', name: 'Damage Boost',   cost: 200, max: 10, desc:'+10% damage / level' },
                    { key: 'rangeBoost',  name: 'Range Boost',    cost: 150, max: 10, desc:'+10% range / level' },
                    { key: 'fireRateBoost', name:'Fire Rate Boost', cost:250,max:10, desc:'+10% fire rate / level' },
                    { key: 'creditBonus', name: 'Credit Bonus',   cost: 300, max: 5,  desc:'+10% rewards / level' }
                ];
                container.innerHTML = '';
                defs.forEach(up => {
                    const level = this.upgrades[up.key] || 0;
                    const cost = up.cost * (level + 1);
                    const canAfford = this.credits >= cost && level < up.max;

                    const card = document.createElement('div');
                    card.className = `unit-card ${!canAfford ? 'disabled' : ''}`;
                    card.innerHTML = `
                        <div class="unit-name">${up.name}</div>
                        <div class="unit-stats">Level: ${level}/${up.max} &nbsp; <span style="color:#8899aa">${up.desc}</span></div>
                        <div class="unit-cost">Cost: ${cost} credits</div>
                        <button class="upgrade-button" ${!canAfford ? 'disabled' : ''} onclick="purchaseUpgrade('${up.key}', ${cost})">UPGRADE</button>
                    `;
                    container.appendChild(card);
                });
            }

            purchaseUpgrade(key) {
                const table = { damageBoost:{cost:200,max:10}, rangeBoost:{cost:150,max:10}, fireRateBoost:{cost:250,max:10}, creditBonus:{cost:300,max:5} };
                const def = table[key]; if (!def) return;
                const level = this.upgrades[key] || 0;
                if (level >= def.max) return;
                const cost = def.cost * (level + 1);
                if (this.credits < cost) { this.showNotification('Insufficient credits!'); return; }
                this.credits -= cost;
                this.upgrades[key] = level + 1;
                this.updateUI();
            }

            updateWaveInfo() {
                const container = document.getElementById('waveInfo');
                const nextWave = this.wave + (this.waveActive ? 0 : 1);
                const isBoss = nextWave % 10 === 0;
                const hpScale = Math.floor((Math.pow(1.12, nextWave - 1) - 1) * 100);
                const dmgScale = hpScale;
                const spdScale = Math.floor(nextWave * 1.5);

                container.innerHTML = `
                    <div style="margin-bottom: 15px;">
                        <strong>Wave ${nextWave}</strong><br>
                        ${isBoss ? '<span style="color:#ff0000;font-weight:bold;">BOSS WAVE</span>' : `Enemies: ${Math.floor(8 + nextWave * 1.5)}`}
                    </div>
                    <div style="font-size: 14px; color: #8899aa; line-height:1.6;">
                        Enemy HP: +${hpScale}%<br>
                        Enemy Speed: +${spdScale}%<br>
                        Enemy Damage: +${dmgScale}%<br>
                        Rewards Bonus: +${Math.floor(this.upgrades.creditBonus * 10)}%
                    </div>
                `;
            }

            updateAchievements() {
                const el = document.getElementById('achievementsSection');
                el.innerHTML = '';
                Object.keys(this.achievements).forEach(key => {
                    const a = this.achievements[key];
                    const row = document.createElement('div');
                    row.className = 'high-score-item';
                    row.style.opacity = a.unlocked ? '1' : '0.5';
                    row.innerHTML = `<span>${a.name}</span><span>${a.unlocked ? '✓' : '—'}</span>`;
                    el.appendChild(row);
                });
            }

            unlockAchievement(key) {
                const a = this.achievements[key];
                if (!a || a.unlocked) return;
                a.unlocked = true;
                this.saveAchievements();
                const toast = document.createElement('div');
                toast.className = 'achievement';
                toast.textContent = `Achievement Unlocked: ${a.name}`;
                document.body.appendChild(toast);
                setTimeout(() => document.body.removeChild(toast), 3000);
            }

            loadAchievements() {
                try {
                    const raw = localStorage.getItem('orbitalDefenseAchievements');
                    if (!raw) return;
                    const saved = JSON.parse(raw);
                    Object.keys(this.achievements).forEach(k => {
                        if (saved[k] && saved[k].unlocked) this.achievements[k].unlocked = true;
                    });
                } catch {}
            }

            saveAchievements() {
                try { localStorage.setItem('orbitalDefenseAchievements', JSON.stringify(this.achievements)); } catch {}
            }

            loadHighScores() {
                const list = document.getElementById('highScoresList');
                let scores = [];
                try { scores = JSON.parse(localStorage.getItem('orbitalDefenseHighScores') || '[]') || []; } catch {}
                scores.sort((a, b) => b.score - a.score);
                scores = scores.slice(0, 10);
                list.innerHTML = scores.length ? scores.map(s => {
                    const date = new Date(s.time).toLocaleDateString();
                    return `<div class="high-score-item"><span>${date}</span><span>${s.score.toLocaleString()}</span></div>`;
                }).join('') : '<div class="unit-stats">No scores yet. Be the first!</div>';
            }

            saveHighScore(score) {
                try {
                    const raw = localStorage.getItem('orbitalDefenseHighScores');
                    const arr = raw ? JSON.parse(raw) : [];
                    arr.push({ score, time: Date.now() });
                    arr.sort((a, b) => b.score - a.score);
                    localStorage.setItem('orbitalDefenseHighScores', JSON.stringify(arr.slice(0, 25)));
                    this.loadHighScores();
                } catch {}
            }

            showNotification(message, duration = 2500) {
                const n = document.createElement('div');
                n.className = 'notification';
                n.innerHTML = `<strong>Command:</strong> ${message}`;
                document.body.appendChild(n);
                setTimeout(() => { if (n.parentNode) n.parentNode.removeChild(n); }, duration);
            }

            showDailyChallenge() {
                let modal = document.getElementById('dailyMenu');
                if (!modal) {
                    modal = document.createElement('div');
                    modal.className = 'menu-container';
                    modal.id = 'dailyMenu';
                    document.getElementById('menuOverlay').appendChild(modal);
                }
                const c = this.dailyChallenge;
                modal.innerHTML = `
                    <h2 class="game-title">DAILY CHALLENGE</h2>
                    <p class="game-subtitle">${c.name}</p>
                    <div style="color:#8899aa; margin-bottom:20px;">${c.desc}</div>
                    <button class="menu-button" id="startChallengeBtn">START CHALLENGE</button>
                    <button class="menu-button secondary" id="backToMenuBtn">BACK</button>
                `;
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('pauseMenu').style.display = 'none';
                document.getElementById('gameOverMenu').style.display = 'none';
                document.getElementById('menuOverlay').style.display = 'flex';
                modal.style.display = 'block';

                const start = () => {
                    // Simple modifiers per challenge type (light touch; expand as desired)
                    if (c.type === 'time') this.waveDelay = 9000;
                    if (c.type === 'units') this.unitCap = 5; // (not enforced in UI yet—expand if desired)
                    if (c.type === 'credits') this.credits = 1500;
                    if (c.type === 'pacifist') this.scoutPacifist = true; // (hook for custom logic)
                    this.startNewGame();
                    modal.style.display = 'none';
                };
                const back = () => {
                    modal.style.display = 'none';
                    document.getElementById('mainMenu').style.display = 'block';
                };
                document.getElementById('startChallengeBtn').onclick = start;
                document.getElementById('backToMenuBtn').onclick = back;
            }

            gameLoop() {
                const step = (ts) => {
                    if (!this._lastFrame) this._lastFrame = ts;
                    const delta = Math.min(64, ts - this._lastFrame); // clamp big jumps
                    this._lastFrame = ts;

                    this.updateGame(delta);
                    this.render();

                    this._raf = requestAnimationFrame(step);
                };
                if (this._raf) cancelAnimationFrame(this._raf);
                this._lastFrame = 0;
                this._raf = requestAnimationFrame(step);
            }
        }

        // Create game and expose minimal globals for inline handlers
        const game = new OrbitalDefenseGame();
        window.game = game;
        window.startNewGame = () => game.startNewGame();
        window.loadGame = () => game.loadGame();
        window.togglePause = () => game.togglePause();
        window.saveGame = () => game.saveGame();
        window.returnToMenu = () => game.returnToMenu();
        window.setSpeed = (s) => game.setSpeed(s);
        window.purchaseUpgrade = (key/*, costIgnored*/) => game.purchaseUpgrade(key);
        window.showDailyChallenge = () => game.showDailyChallenge();
    })();
    </script>
</body>
</html>
